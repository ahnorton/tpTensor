(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True),BeginPackage["PartialDerivative`"]] 


(* ::Input::Initialization:: *)
pD::usage="pD[f,x1,x2,...,xn]  is the partial deriv of f  w.r.t.  x1, x2, ..., xn. ";


(* ::Input::Initialization:: *)
Indpt::usage="See: ??Indpt";
ClearIndpt::usage="See: ??ClearIndpt";
IndptQ::usage="See: ??IndptQ";
SetpDOrdering::usage="See: ??SetpDOrdering";
pDOrdering::usage="See: ??pDOrdering";
pDdebug::usage="See: ??pDdebug";
pDDefine::usage="See: ??pDDefine";
SetpD::usage="See: ??SetpD";
ClearpD::usage="See: ??ClearpD";
pDValues::usage="See: ??pDValues";
pDData::usage="See: ??pDValues";
ListToRowBox::usage="See: ??ListToRowBox";
DeleteElements::usage="See: ??DeleteElements";


(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True),Begin["`Private`"]];


(* ::Input::Initialization:: *)
Clear[pD]


(* ::Input::Initialization:: *)
ListToRowBox[x_List,form_,space_]:=RowBox[Riffle[Map[ToBoxes[#,form]&,x],space]]


(* ::Input::Initialization:: *)
ListToRowBox[x_List,form_]:=RowBox[Map[ToBoxes[#,form]&,x]]


(* ::Input::Initialization:: *)
pD/:MakeBoxes[pD[X_,a__],StandardForm]:=SubscriptBox[ToBoxes[X,StandardForm],ListToRowBox[{a},StandardForm,"\[InvisibleComma]\[NegativeThickSpace]\[NegativeMediumSpace]"]]


(* ::Input::Initialization:: *)
pD[expr_List,x__]:=Map[pD[#,x]&,expr]
pD[expr_,x_List]:=Map[pD[expr,#]&,x]
pD[a_]:=a
pD[a_?NumericQ,x__]=0;
pD[x_,x_]/;Head[x]=!=List =1;
pD[expr_Plus,x__] :=Map[pD[#,x]&,expr]

(* pD[a_ b_,x__]:=pD[a pD[b,First[{x}]]+b pD[a,First[{x}]],Apply[Sequence,Rest[{x}]]] *)

pD[a_Times,x__]:=pD[
Module[{i},Sum[MapAt[pD[#,First[{x}]]&,a,i],{i,Length[a]}]],
Apply[Sequence,Rest[{x}]]]

pD[a_^b_?NumericQ,x__] :=pD[b a^(b-1) pD[a,First[{x}]],Apply[Sequence,Rest[{x}]]]


(* ::Input::Initialization:: *)
pD[a_^b_,x__] :=pD[b a^(b-1) pD[a,First[{x}]]+a^b Log[a]pD[b,First[{x}]],Apply[Sequence,Rest[{x}]]]


(* ::Input::Initialization:: *)
pD[a_,x__]/;SortBy[{x},pDIndex]=!={x}:=pD[a,Apply[Sequence,SortBy[{x},pDIndex]]]


(* ::Input::Initialization:: *)
(* SetAttributes[pD,Flat] *)


(* ::Input::Initialization:: *)
pD[pD[a_,x1__],x2__]:= pD[a,x1,x2]


(* ::Input::Initialization:: *)
pD[Log[a_],x__]:=pD[pD[a,First[{x}]]/a,                                Apply[Sequence,Rest[{x}]]]
pD[Exp[a_],x__]:=pD[pD[a,First[{x}]]Exp[a],                       Apply[Sequence,Rest[{x}]]]
pD[Sin[a_],x__]:=pD[pD[a,First[{x}]]Cos[a],                       Apply[Sequence,Rest[{x}]]]
pD[Cos[a_],x__]:=pD[pD[a,First[{x}]](-Sin[a]),                Apply[Sequence,Rest[{x}]]]
pD[Csc[a_],x__]:=pD[pD[a,First[{x}]](-Cot[a] Csc[a]),  Apply[Sequence,Rest[{x}]]]
pD[Sec[a_],x__]:=pD[pD[a,First[{x}]]Sec[a] Tan[a],         Apply[Sequence,Rest[{x}]]]
pD[Tan[a_],x__]:=pD[pD[a,First[{x}]]Sec[a]^2,                      Apply[Sequence,Rest[{x}]]]
pD[Cot[a_],x__]:=pD[pD[a,First[{x}]](-Csc[a]^2),               Apply[Sequence,Rest[{x}]]]
pD[Sinh[a_],x__]:=pD[pD[a,First[{x}]]Cosh[a],                           Apply[Sequence,Rest[{x}]]]
pD[Cosh[a_],x__]:=pD[pD[a,First[{x}]]Sinh[a],                           Apply[Sequence,Rest[{x}]]]
pD[Tanh[a_],x__]:=pD[pD[a,First[{x}]]Sech[a]^2,                          Apply[Sequence,Rest[{x}]]]
pD[Csch[a_],x__]:=pD[pD[a,First[{x}]](-Coth[a] Csch[a]),    Apply[Sequence,Rest[{x}]]]
pD[Sech[a_],x__]:=pD[pD[a,First[{x}]](-Sech[a] Tanh[a]),    Apply[Sequence,Rest[{x}]]]
pD[Coth[a_],x__]:=pD[pD[a,First[{x}]](-Csch[a]^2),                   Apply[Sequence,Rest[{x}]]]


(* ::Input::Initialization:: *)
pDDefine[f_]:=Module[{},pD[f[a_],x__]:=pD[pD[a,First[{x}]]Derivative[1][f][a], Apply[Sequence,Rest[{x}]]]]


(* ::Input::Initialization:: *)
pDDefine[ArcSin]
pDDefine[ArcCos]
pDDefine[ArcTan]
pDDefine[ArcCot]
pDDefine[ArcSec]
pDDefine[ArcCsc]

pDDefine[ArcSinh]
pDDefine[ArcCosh]
pDDefine[ArcTanh]
pDDefine[ArcCoth]
pDDefine[ArcSech]
pDDefine[ArcCsch]


(* ::Input::Initialization:: *)
pD[a_->b_,x__]:=pD[a,x]->pD[b,x]


(* ::Input::Initialization:: *)
pD[a_,x_?NumericQ]:=(
Print["The 2nd argument can not be numeric:  pD[",a,", ",x,"]"];Abort[])


(* ::Input::Initialization:: *)
AnyTrueQ[x_,test_]:=TrueQ[Scan[If[test[#],Return[True]]&,x]]


(* ::Input::Initialization:: *)
FirstTruePosition[x_,test_]:=Module[{n,s},
n=0;
s=Scan[If[test[#],Return[n+1],++n]&,x];
If[s===Null,0,s]]


(* ::Input::Initialization:: *)
Clear[pDData]


(* ::Input::Initialization:: *)
pDData[]={};


(* ::Input::Initialization:: *)
pDData[X_]:=Select[pDData[],(First[#]===X)&]


(* ::Input::Initialization:: *)
pDValues[X___]:=Map[(Apply[HoldForm[pD],Most[#]]==Last[#])&,pDData[X]]


(* ::Input::Initialization:: *)
SetpD[X_,a__,val_]:=Module[{b,bs,Xs,vs,str},
b=SortBy[{a},pDIndex];
bs=ToString[b,InputForm];
Xs=ToString[X,InputForm];
vs=ToString[val,InputForm];
str = "pD["<>Xs<>",c$__] /; ContainsAll[{c$},"<>bs<>"]:= pD["<>vs<>", Apply[Sequence,DeleteElements[{c$},"<>bs<>"]]]";
ToExpression[str];
pDData[]=Append[DeleteCases[pDData[],{X,Apply[Sequence, b],_}],{X,Apply[Sequence, b],val}];
str
]


(* ::Input::Initialization:: *)
ClearpD[X_,a__]:=Module[{b},
b=SortBy[{a},pDIndex];
ToExpression[RowBox[{"pD[",X,",","c$__] /; ContainsAll[{c$},",ToBoxes[b],"]=."}]];
pDData[]=DeleteCases[pDData[],{X,Apply[Sequence, b],_}];
]


(* ::Input::Initialization:: *)
ClearpD[X_]:=(Map[Apply[ClearpD,Most[#]]&,pDData[X]];)


(* ::Input::Initialization:: *)
DeleteElements[a_List,b_List]:= Fold[DeleteCases[#1,#2,1,1]&,a,b]


(* ::Input::Initialization:: *)
pD[y_SeriesData,x__]:=Module[{t},
t=Part[y,1];
If[Apply[Or,Map[(!SameQ[#,0])&,pD[t,{x}]]],Print["pD[ ] does not yet take derivatives w.r.t. series expansion variables."];
If[!MemberQ[{x},t],Print["You may need to declare Indpt[{",t,",",x,"}], or similar."]];
Abort[]];
MapAt[pD[#,x]&,y,3]]


(* ::Input::Initialization:: *)
Clear[IndptQ]
IndptQ[fns_List,vars_List]:=Module[{i,j,J,n,m,zero},
J=pD[fns,vars];
n=Length[fns];
m=Length[vars];
zero=Table[0,{i,1,n},{j,1,m}];
J===zero]


(* ::Input::Initialization:: *)
IndptQ[coords_List]:=Module[{J,n},
J=pD[coords,coords];
n=Length[coords];
J===IdentityMatrix[n]]


(* ::Input::Initialization:: *)
IndptQ[f_,vars_List]:=IndptQ[{f},vars]/;Head[f]=!=List
IndptQ[fns_List,var_]:=IndptQ[fns,{var}]/;Head[var]=!=List
IndptQ[fn_,var_]:=IndptQ[{fn},{var}]/;Head[fn]=!=List && Head[var]=!=List


(* ::Input::Initialization:: *)
Indpt[fn_List,var_List]:=Module[{i,j,J,n,m},
J=pD[fn,var];
n=Length[fn];
m=Length[var];
Do[If[Head[J[[i,j]]]===pD,SetpD[fn[[i]],var[[j]],0]],{i,1,n},{j,1,m}]]


(* ::Input::Initialization:: *)
Indpt[coords_List]:=Indpt[coords,coords]
Indpt[f_,vars_List]/;Head[f]=!=List:=Indpt[{f},vars]
Indpt[fns_List,var_]/;Head[var]=!=List:=Indpt[fns,{var}]
Indpt[fn_,var_]/;Head[fn]=!=List && Head[var]=!=List:=Indpt[{fn},{var}]


(* ::Input::Initialization:: *)
ClearIndpt[fn_List,var_List]:=Module[{i,j,J,n,m},
n=Length[fn];
m=Length[var];
Off[Unset::"norep"];
Do[If[fn[[i]]=!=var[[j]],ClearpD[fn[[i]],var[[j]]]],{i,1,n},{j,1,m}];
On[Unset::"norep"];]


(* ::Input::Initialization:: *)
ClearIndpt[coords_List]:=ClearIndpt[coords,coords]
ClearIndpt[f_,vars_List]/;Head[f]=!=List:=ClearIndpt[{f},vars]
ClearIndpt[fns_List,var_]/;Head[var]=!=List:=ClearIndpt[fns,{var}]
ClearIndpt[fn_,var_]/;Head[fn]=!=List && Head[var]=!=List:=ClearIndpt[{fn},{var}]


(* ::Input::Initialization:: *)
Clear[IndptQ]
IndptQ[fns_List,vars_List]:=Module[{i,j,J,n,m,zero},
J=pD[fns,vars];
n=Length[fns];
m=Length[vars];
zero=Table[0,{i,1,n},{j,1,m}];
J===zero]


(* ::Input::Initialization:: *)
IndptQ[coords_List]:=Module[{J,n},
J=pD[coords,coords];
n=Length[coords];
J===IdentityMatrix[n]]


(* ::Input::Initialization:: *)
IndptQ[f_,vars_List]:=IndptQ[{f},vars]/;Head[f]=!=List
IndptQ[fns_List,var_]:=IndptQ[fns,{var}]/;Head[var]=!=List
IndptQ[fn_,var_]:=IndptQ[{fn},{var}]/;Head[fn]=!=List && Head[var]=!=List


(* ::Input::Initialization:: *)
Clear[SetpDOrdering,pDIndex]
pDOrdering={};
SetAttributes[pDIndex,Listable]
SetpDOrdering[vars_List]:= Module[{},
pDOrdering=vars;
Clear[pDIndex];
Do[pDIndex[vars[[i]]]=i,{i,1,Length[vars]}]]


(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True),
End[];
EndPackage[]];
