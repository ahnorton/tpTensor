(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True),BeginPackage["RuleNumbers`"]]


(* ::Input::Initialization:: *)
RuleNumbers::usage="The RuleNumbers package allows easy tracing of what
user-defined rules have been used in the evaluation of an expression.

Example:

    AddRule[  y[x_?EvenQ] := 1 + x ]
    AddRule[  y[x_?OddQ]  := \!\(\*SuperscriptBox[\(x\), \(\(\\\ \)\(2\)\)]\)    ]

    RulesUsed={}; y[1]; y[2]; y[3];
    RulesUsed
    
The above sequence of input statements will give the result { 2, 1, 2 }  if the above are the 
first two rules added. 

Note that in postfix form braces must be used since   a := b // AddRule   is interpreted as   a := AddRule[b].

See also:  ? AddRule";


(* ::Input::Initialization:: *)
RulesUsed::usage="RulesUsed[ x ]  returns a list of the rule numbers of the rules used to evaluate x, 
followed by the result of evaluating x .

See also:  ? PrintRulesUsed,  ? AddRule";


(* ::Input::Initialization:: *)
PrintRulesUsed::usage="PrintRulesUsed[ x ]  prints out the rules used to evaluate x. 

The returned value is the evaluation of  x.

See also:  ? RulesUsed,  ? AddRule";


(* ::Input::Initialization:: *)
AddRule::usage="AddRule[ a := b ]   adds the rule   a := b  to the environment, but in a form that can be 
watched by the funtions  RulesUsed  and  PrintRulesUsed.

AddRule[ tag, a := b ]   in addition sets  ruleTag[ n ] = tag,  where  n  is the assigned rule number.
The optional tag is any integer, string, etc., to identify a collection of rules. This allows output to be filtered 
according to tag values. 

AddRule  only works with  SetDelayed ( := ).   It does not work with  Set ( = ),  RuleDelayed ( \[RuleDelayed] ), or  Rule ( \[Rule] ). 

See also:  ? RulesUsed,  ? PrintRulesUsed";


(* ::Input::Initialization:: *)
rule::usage="rule[ n ]   for  n = 1, 2, ...   is the nth rule that was added with  AddRule[ ]. 

The value of rule[ n ]  is wrapped by  HoldForm[ ]." ;


(* ::Input::Initialization:: *)
ruleTag::usage="ruleTag[ n ]   for  n = 1, 2, ...   is the tag (if any) of the nth rule that was added with  AddRule[ ]. " ;


(* ::Input::Initialization:: *)
StartDebug::usage="StartDebug[]   turns on printing of rules used, as they are used.

StartDebug[n]  sets  $RecursionLimit = n.    
StartDebug[]    sets  $RecursionLimit = 20,  which is as small as possible so as to limit output while infinite loops are being debugged.    

See also:  ? StopDebug";


(* ::Input::Initialization:: *)
StopDebug::usage="StopDebug[]   turns off printing of rules used, as they are used.

StopDebug[n]  sets  $RecursionLimit = n.    
StopDebug[]    sets  $RecursionLimit = 10\[VeryThinSpace]000, which should be large enough for most calculations 
                                                     (the Mathematica default is only 256, and too small for tpTensor).

See also:  ? StartDebug";


(* ::Input::Initialization:: *)
LogAsUsed::usage="LogAsUsed[n]  appends n  to RulesUsedList.  This is not a user function.  Don't use it. 

LogAsUsed[n]  is see in the output from  ??  or  Definition[ ]  for functions that have rules defined using AddRule[].
LogAsUsed[n]  is not Private so as to prevent messy output like  tpTensor`RuleNumbers`Private`LogAsUsed[n]. ";


(* ::Input::Initialization:: *)
RuleStats::usage="RuleStats[n]  returns the number of times  rule[n]  has been used while in debug mode, as initiated or continued by StartDebug[].

To see all values, use  Definition[RuleStats],  or better,  PrintRuleStats[ ].

See also: ? ClearRuleStats ,  ? PrintRuleStats[ ]";


(* ::Input::Initialization:: *)
ClearRuleStats::usage="ClearRuleStats[ ]   resets all rule usage counts to zero.

See also:  ? RuleStats";  


(* ::Input::Initialization:: *)
PrintRuleStats::usage ="PrintRuleStats[ ]   will print a table of rule statistics.

See also:  ? RuleStats ";


(* ::Input::Initialization:: *)
UnsetRule::usage ="UnsetRule[n]  removes the automatic use of rule[n]. 

The value of  rule[n]  is unchanged. Automatic use of rule[n]  can be restored by  ResetRule[n].

See also:  StepRule[n]";


(* ::Input::Initialization:: *)
ResetRule::usage="ResetRule[n]  restores the automatic use of rule[n]. 

See also: ? UnsetRule[n],  ? StepRule[n]";


(* ::Input::Initialization:: *)
StepRule::usage = "StepRule[n]  evaluates to a  RuleDelayed  version of rule[n].  

If automatic use of  rule[n]  has been disabled using  UnsetRule[n],  then  rule[n]  can be used in the form

                                         expression /. StepRule[n] ,

thus enabling step-by-step evaluation. 

See also:  ? UnsetRule ";


(* ::Input::Initialization:: *)
$DebugDelay::usage="$DebugDelay  is the delay in seconds between applying rules in debugging mode ( as initiated by  StartDebug[] ).

The default is  $DebugDelay = 0.15. This allows output to be viewed as computed, and aborted in real time using  Alt + '.'
If one sets  $DebugDelay = 0  then many 1000s of lines of output can be buffered for printing before an abort will take effect.

See also:  ? AbortAtMessage";  


(* ::Input::Initialization:: *)
AbortAtMessage::usage="AbortAtMessage[ x ]   attempts to evaluate  x, but will abort as soon as any message is issued.

AbortAtMessage[ x ]   is useful for debugging large expressions that take too long to evaluate using a non-zero $DebugDelay.
The output may be very large, but the interesting part will be at the end. 

AbortAtMessage[ x ]   is typically used in debugging mode ( as initiated by  StartDebug[] ), in which case  $DebugDelay
is temporarily set to 0.  

AbortAtMessage[ x ]  can be used in normal computation to abort sooner rather than later if messages are being issued.";


(* ::Input::Initialization:: *)
PrintRules::usage=
"PrintRules[ n_Integer ]                           
       prints  the last  n  rules  from  RulesUsedList.
PrintRules[ ]  defaults to  PrintRules[7]          
       the default can be set to n (rather than 7) by  PrintRules[ ] = PrintRules[n].
PrintRules[ n_List ]                              
       prints  rule[i]  for each  i  in the list n.
PrintRules[ {} ]                               
       prints all defined rules.
PrintRules[ n_Integer,  test ]          
       prints only those of the last n rules of  RulesUsedList  for which  test[ tag ]  is True, where  tag  is
       the tag-value (if any) that was set when AddRule was used.          

Only rules that have been defined using  AddRule[ ]  are printed. Bugs within other rules will be difficult to find. 

See also:  ? AddRule ";


(* ::Input::Initialization:: *)
Snoop::usage="Snoop[ x ]   prints  x  then returns  x.  Wrap  Snoop[ ]  around any expression  x  that appears within a larger expression 
(eg. within a module) and the value of  x  will be printed each time expression  x  is evaluated.

Snoop[ label, x ]   will label the printed output, so that output from different snoops can be distinguished.

Snooping can be turned on/off by setting the variable  $Snooping  to True/False.

StartDebug[]  uses  Snoop[ ]  to print the return values for any rule defined by AddRule[ ].
";


(* ::Input::Initialization:: *)
Snoopr::usage="Snoopr[ x ]  is the same as   Snoop[\"    rhs =   \", x ].

You will see Snoopr[ ] in the definition of any symbol for which rules have been defined using AddRule[ ].

See also:  ? Snoop, ? Definition ";


(* ::Input::Initialization:: *)
SaveDebugOutput::usage="SaveDebugOutput[ x ]   evaluates and returns  x ,  saving debug output into the two lists snoopedRuleNumber and snoopedExpression.

This function can be used with expressions  x  that have far too many evaluation steps for using debug mode (as initiated by StartDebug[]).
Use  PrintDebugOutput[]  to print selections of the collected data.  SaveDebugOutput[ ] initializes the data lists to {}. 

See also:  ? PrintDebugOutput ";


(* ::Input::Initialization:: *)
PrintDebugOutput::usage="PrintDebugOutput[]  will print data collected by  SaveDebugOutput[ x ].

PrintDebugOutput[]  prints all data for any evaluation that took less than 100 steps.
PrintDebugOutput[ \!\(\*SubscriptBox[\(n\), \(0\)]\), \!\(\*SubscriptBox[\(n\), \(\(1\)\(\\\ \)\)]\)]   prints data for steps  \!\(\*SubscriptBox[\(n\), \(0\)]\)  to  \!\(\*SubscriptBox[\(n\), \(1\)]\).
PrintDebugOutput[ n ]   prints data for the first  n  steps.
PrintDebugOutput[ -n ]   prints data for the last  n  steps.

See also:  ? SaveDebugOutput ";


(* ::Input::Initialization:: *)
$Snooping = False;
$DebugDelay = 0.15;
RulesUsedList={}; 
LengthRulesUsedList = 1000;
snoopedExpression={};
snoopedRuleNumber={};



(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True) ,Begin["`Private`"]];


(* ::Input::Initialization:: *)
RulesUsedList=Table[0,{LengthRulesUsedList}];


(* ::Input::Initialization:: *)
label[n_]:="rule[\[VeryThinSpace]"<>ToString[n]<>"\[VeryThinSpace]]:"


(* ::Input::Initialization:: *)
ClearRuleStats[]:=(Clear[RuleStats];RuleStats[n_]:=0)
ClearRuleStats[]


(* ::Input::Initialization:: *)
StopDebug[]   :=(
$Snooping = False;
LogAsUsed[n_]:=(RulesUsedList=Append[Rest[RulesUsedList],n];++RuleStats[n]))


(* ::Input::Initialization:: *)
StopDebug[r_Integer]   :=(
$Snooping = False;
LogAsUsed[r]:=(RulesUsedList=Append[Rest[RulesUsedList],r];++RuleStats[r]))


(* ::Input::Initialization:: *)
StartDebug[]:=(
$Snooping = True;
LogAsUsed[n_]:=(RulesUsedList=Append[Rest[RulesUsedList],n];Print[label[n],"  ",rule[n]]; ++RuleStats[n];Pause[$DebugDelay]))


(* ::Input::Initialization:: *)
StartDebug[r_]:=(
$Snooping = True;
LogAsUsed[r]:=(RulesUsedList=Append[Rest[RulesUsedList],r];Print[label[r],"  ",rule[r]]; ++RuleStats[r];Pause[$DebugDelay]))


(* ::Input::Initialization:: *)
StopDebug[]


(* ::Input::Initialization:: *)
PrintRuleStats[]:=Do[Print[label[n],"  ",RuleStats[n]],{n,1,RuleNumber}]


(* ::Input::Initialization:: *)
Clear[RulesUsed]
SetAttributes[RulesUsed,HoldAllComplete]
RulesUsed[f_]:=Module[{n,fval},
RulesUsedList=Table[0,{LengthRulesUsedList}];
Reverse[{f,DeleteCases[RulesUsedList,0]}]]


(* ::Input::Initialization:: *)
PrintRules[n_List]:=Module[{r},
Print[TableForm[
Transpose[
{Map[label,n],
Map[rule,n]}],
TableSpacing->3.5]]]

PrintRules[{}]:=PrintRules[Range[RuleNumber]]
PrintRules[n_Integer]:=PrintRules[Take[RulesUsedList,-Min[n,Length[RulesUsedList]]]]
PrintRules[]:=PrintRules[7]


(* ::Input::Initialization:: *)
PrintRules[n_Integer/;n>0,test_]:=Module[{n0,n1,r},
n1=Length[RulesUsedList];
n0=n1-n+1;
r=Pick[RulesUsedList[[n0;;n1]],Map[test,Map[ruleTag,RulesUsedList[[n0;;n1]]]]];
If[!r==={},PrintRules[r]]]


(* ::Input::Initialization:: *)
Clear[PrintRulesUsed]
SetAttributes[PrintRulesUsed,HoldAllComplete]
PrintRulesUsed[x_]:=(
StopDebug[];
Print[TableForm[
Transpose[
{Map[label,First[RulesUsed[x]]],
Map[rule,First[RulesUsed[x]]]}],
TableSpacing->3.5]];x)


(* ::Input::Initialization:: *)
RuleNumber =0;
Clear[AddRule]
SetAttributes[AddRule,HoldAllComplete]
AddRule[tag_,s_SetDelayed]:=Module[{n,s1,s2,def,h},
RuleNumber +=1; 
n = RuleNumber;
If[!tag==="notag",ruleTag[RuleNumber]=tag];
h=HoldForm[s];
s1=StringDrop[StringDrop[ToString[Extract[h,{1,1},HoldComplete],InputForm],StringLength["HoldComplete["]],-1];
If[StringLength[s1]>=9&&StringTake[s1,9]==="Evaluate[",
s1=StringDrop[StringDrop[s1,9],-1];
s1=ToString[ToExpression[s1,InputForm],InputForm]];
s2=StringDrop[StringDrop[ToString[Extract[h,{1,2},HoldComplete],InputForm],StringLength["HoldComplete["]],-1];
def=s1<>" := (LogAsUsed["<>ToString[n]<>"]; "<>"Snoopr["<>s2<>"])";
ToExpression[def,InputForm];
rule[n]=Apply[Defer,h];
Defer[rule][RuleNumber]]


(* ::Input::Initialization:: *)
AddRule[s_SetDelayed]:=AddRule["notag",s]


(* ::Input::Initialization:: *)
$SaveSnoop = False;
SetAttributes[Snoop,HoldAllComplete]
SetAttributes[Snoopr,HoldAllComplete]


(* ::Input::Initialization:: *)
Snoop[x_]:=(
If[$Snooping,Print[HoldForm[x]]];
If[$SaveSnoop,AppendTo[snoopedExpression,HoldForm[x]]];
x)


(* ::Input::Initialization:: *)
Snoop[label_,x_]:=(
If[$Snooping,Print[label,HoldForm[x]]];
If[$SaveSnoop,AppendTo[snoopedExpression,HoldForm[x]]];
x)


(* ::Input::Initialization:: *)
Snoopr[x_]:=(
If[$Snooping,Print["    rhs =   ",HoldForm[x]]];
If[$SaveSnoop,AppendTo[snoopedExpression,HoldForm[x]]];
x)


(* ::Input::Initialization:: *)
SetAttributes[Unset1,HoldAllComplete]
Unset1[a_,b_]:=Unset[a]
UnsetRule[n_]:=Apply[Identity,rule[n]/.SetDelayed->Unset1]


(* ::Input::Initialization:: *)
ResetRule[r_]:=Module[{n,ans},
n=RuleNumber;
RuleNumber=r-1;
ans=Apply[AddRule,rule[r]];
RuleNumber=n;
ans]


(* ::Input::Initialization:: *)
SetAttributes[UnsetRule,Listable]
SetAttributes[ResetRule,Listable]


(* ::Input::Initialization:: *)
AddRule[r_Defer]:= Apply[AddRule,r]


(* ::Input::Initialization:: *)
StepRule[n_]:=Apply[Identity,rule[n]/.SetDelayed->RuleDelayed]


(* ::Input::Initialization:: *)
AbortAtMessage[x_]:= Module[{debugDelay,ans},
StopDebug[];
ans=Check[x,Abort[]];
Print[RulesUsedList];
ans]


(* ::Input::Initialization:: *)
SetAttributes[SaveDebugOutput, HoldAllComplete]

SaveDebugOutput[x_]:= Module[{xval},
$Snooping=False;
$SaveSnoop = True;
snoopedExpression ={};
snoopedRuleNumber={};
LogAsUsed[n_]:=(
RulesUsedList=Append[Rest[RulesUsedList],n];
AppendTo[snoopedRuleNumber,n];
++RuleStats[n];);
xval=CheckAbort[ReleaseHold[x],CleanupAfterSavingDebugOutput[]];
CleanupAfterSavingDebugOutput[];
xval
]


(* ::Input::Initialization:: *)
CleanupAfterSavingDebugOutput[]:=Module[{n},
$SaveSnoop=False;
StopDebug[];
If[!Length[snoopedRuleNumber]===Length[snoopedExpression],
n=Min[Length[snoopedRuleNumber],Length[snoopedExpression]];
snoopedRuleNumber = Take[snoopedRuleNumber,n];
snoopedExpression = Take[snoopedExpression,n];]]


(* ::Input::Initialization:: *)
PrintDebugOutput[n1_,n2_]:=
Do[
Print[j,"  ",Defer[rule][snoopedRuleNumber[[j]]],":  ",rule[snoopedRuleNumber[[j]]]];
Print["       rhs = ",snoopedExpression[[j]]],
{j,n1,n2}]


(* ::Input::Initialization:: *)
PrintDebugOutput[]:= If[
Length[snoopedRuleNumber]<100,
PrintDebugOutput[1,Length[snoopedRuleNumber]],
Print["Debug output for ",Length[snoopedRuleNumber]," steps has been saved."];Print["Use  PrintDebugOutput[\!\(\*SubscriptBox[\(n\), \(0\)]\),\!\(\*SubscriptBox[\(n\), \(1\)]\)]  to print output from steps \!\(\*SubscriptBox[\(n\), \(0\)]\) to \!\(\*SubscriptBox[\(n\), \(1\)]\)."];
Print["Use  PrintDebugOutput[n]  to print output from the first n steps."];
Print["Use  PrintDebugOutput[-n]  to print output from the last n steps."];]


(* ::Input::Initialization:: *)
PrintDebugOutput[n_]:=If[n>0,PrintDebugOutput[1,n],PrintDebugOutput[Length[snoopedRuleNumber]+n+1,Length[snoopedRuleNumber]]]


(* ::Input::Initialization:: *)
If[!(Global`EditingMode===True),
End[];
EndPackage[]];
