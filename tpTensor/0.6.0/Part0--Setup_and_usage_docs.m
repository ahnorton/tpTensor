(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["tpTensor`"];
EndPackage[]


(* ::Input::Initialization:: *)
Needs["RuleNumbers`"];


(* ::Input::Initialization:: *)
Needs["LeviCivitaMTW`"]
Needs["PartialDerivative`"]
Needs["TeXit`"]


(* ::Input::Initialization:: *)
ArgumentChecking = True;


(* ::Input::Initialization:: *)
$WedgeNormStartup= "Standard";


(* ::Input::Initialization:: *)
degChecking = False;


(* ::Input::Initialization:: *)
tpQuiet=True;
degChecking=False;


(* ::Input::Initialization:: *)
FindRule[n_] :=( NotebookFind[EvaluationNotebook[],"rule["<>ToString[n]<>"]"];)


(* ::Input::Initialization:: *)
Hyperlink["Available characters","paclet:guide/ListingOfNamedCharacters"]


(* ::Input::Initialization:: *)
tpTensorFunctions = {
                                        "    ? help                  ",                                         
                                        "    ? about                 ", 
                                        "    ? man                   ", 
                                        "    ? deg                   ", 
                                        "    ? degCheck              ", 
                                        "    ? NewConstant           ", 
                                        "    ? ClearConstant         ",
                                        "    ? NewField              " ,
                                        "    ? ClearField            " ,
                                        "    ? FieldQ                " ,
                                        "    ? ConstantQ             " ,
                                        "    ? AngleBracket          " ,
                                        "    ? CircleTimes           " ,
                                        "    ? DependsQ              " ,
                                        "    ? SeriesProduct         " ,
                                        "    ? StrutedTensor         " ,
                                        "    ? SimplifyTensor        " ,
                                        "    ? FullSimplifyTensor    " ,
                                        "    ? ExpandTensor          " ,
                                        "    ? ExpandAllTensor       " ,
                                        "    ? struts                " ,
                                        "    ? costruts              " ,
                                        "    ? strutPair             " ,
                                        "    ? gradient              " ,
                                        "    ? Del                   " ,
                                        "    ? rev                   " ,
                                        "    ? CyclicSum             " ,
                                        "    ? div                   " ,
                                        "    ? curl                  " ,
                                        "    ? TraceFreeSquare       " ,
                                        "    ? LeviCivita            " ,
                                        "    ? LeviCivitaUp          ",
                                        "    ? mv                    ",
                                        "    ? mvInverse             ",
                                        "    ? mvCyclic              ",
                                        "    ? mvSignature           ",
                                        "    ? SquareBracket         ",
                                        "    ? SetmvArgLengthFixed   ",
                                        "    ? SetmvArgLengthVariable",
                                        "    ? sym                   ",
                                        "    ? Sym                   ",
                                        "    ? EvaluateSym           ",
                                        "    ? alt                   ",
                                        "    ? AssumeSymmetric       ",
                                        "    ? ForgetAssumeSymmetric ",
                                        "    ? SymQ      ",
                                        "    ? AssumeAntisymmetric       ",
                                        "    ? ForgetAssumeAntisymmetric ",
                                        "    ? AntisymQ      ",
                                        "    ? \[Eta]mat                  ",
                                        "    ? deg0Q                 "
};


(* ::Input::Initialization:: *)
help :=Column[tpTensorFunctions]


(* ::Input::Initialization:: *)
help::usage ="?\[VeryThinSpace]help
                                                                       \!\(\*
StyleBox[\"Welcome\",\nFontFamily->\"DejaVu Sans\",\nFontSize->16]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSize->16]\)\!\(\*
StyleBox[\"to\",\nFontFamily->\"DejaVu Sans\",\nFontSize->16]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSize->16]\)\!\(\*
StyleBox[\"tpTensor\",\nFontFamily->\"DejaVu Sans\",\nFontSize->16]\)

The command  'help'  will list all of the built-in  tpTensor functions,  printed in the form  ' ? name ' .  The command  ' ? name '   
will print documentation for the named function.  The 'help'  output is therefore useful for cut-and-paste, and for quickly 
finding your way around tpTensor (at this stage, tpTensor does not use Mathematica-style F1-key help pages).

To see the  ?-documentation  \!\(\*
StyleBox[\"for\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"all\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"of\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"functions\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"provided\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"by\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"tpTensor\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\),  use the tpTensor command  'man'  ( or  'manual' ).

tpTensor can be loaded quietly  ( without this Welcome message )  by setting   tpQuiet = True   before doing   << tpTensor` .";



(* ::Input::Initialization:: *)
If[Global`tpQuiet=!= True, ToExpression["?help"]]


(* ::Input::Initialization:: *)
man :=  (ToExpression[ First[help]];)


(* ::Input::Initialization:: *)
man::usage = "?\[VeryThinSpace]man

The command  'man'  ( or 'manual' )  will print the ?-documentation  \!\(\*
StyleBox[\"for\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"all\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[
StyleBox[
RowBox[{
StyleBox[\" \",\nFontSize->16], \" \"}]],\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"of\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"functions\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"provided\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"by\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"tpTensor\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\).

'man'  is the same as doing   ' ? name '  for each function listed by the command  'help',  and is defined as 

man :=  (ToExpression[ First[help]];)  ";


(* ::Input::Initialization:: *)
manual:=man


(* ::Input::Initialization:: *)
about::usage="?\[VeryThinSpace]\[VeryThinSpace]about

\!\(\*
StyleBox[\"tpTensor\",\nFontFamily->\"DejaVu Sans\",\nFontSize->16,\nFontWeight->\"Plain\"]\) was written in 03-04\[VeryThinSpace]/\[VeryThinSpace]2010, by Andrew Norton. 

The main design aim for  tpTensor was that it should be simple and intuitive. The result is that: 

 \!\(\*
StyleBox[\"\[Bullet]\",\nFontFamily->\"DejaVu Sans\",\nFontSize->18]\)  tpTensor's input\[VeryThinSpace]/\[VeryThinSpace]output is very readable and looks nice.
 \!\(\*
StyleBox[\"\[Bullet]\",\nFontFamily->\"DejaVu Sans\",\nFontSize->18]\)  learning how to use tpTensor is trivial, with almost nothing for the casual user to remember. 
 \!\(\*
StyleBox[\"\[Bullet]\",\nFontFamily->\"DejaVu Sans\",\nFontSize->18]\)  the mathematical notation and conventions used by tpTensor are those of the text \!\(\*
StyleBox[\"Gravitation\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*SuperscriptBox[\(.\), 
StyleBox[\"*\",\nFontFamily->\"DejaVu Sans\",\nFontSize->12]]\) 
 \!\(\*
StyleBox[\"\[Bullet]\",\nFontFamily->\"DejaVu Sans\",\nFontSize->18]\)  tpTensor could be used for teaching at various levels, from 3D vector calculus through to general relativity.
 \!\(\*
StyleBox[\"\[Bullet]\",\nFontFamily->\"DejaVu Sans\",\nFontSize->18]\)  tpTensor is well documented. It also comes with several tutorial and example Mathematica Notebooks.  
 
Simple though it is, \!\(\*
StyleBox[\"tpTensor\",\nFontFamily->\"DejaVu Sans\",\nFontSize->16,\nFontWeight->\"Plain\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSize->16,\nFontWeight->\"Plain\"]\)is still powerful enough to be of use to the average relativist. Enjoy!

Feel free to send me wish-lists or contributed code.
Likewise for Notebooks that might be suitable for inclusion with the Examples or Tutorials. 
And do please let me know about any bugs\[VeryThinSpace]!

Dr Andrew Norton
Max Planck Institute for Gravitational Physics (Albert Einstein Institute)
Am Muehlenberg 1
D-14476 Golm
Germany
email: andrew.norton@aei.mpg.de

\!\(\*SuperscriptBox[\(\\\ \), 
StyleBox[\"*\",\nFontFamily->\"DejaVu Sans\",\nFontSize->12]]\) A choice not entirely based on personal preference -- I actually spent quite some time comparing the notations 
   and conventions used in numerous relativity and differential geometry texts. \!\(\*
StyleBox[\"Gravitation\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\) (Misner, Thorne and Wheeler) 
   also happened to be the most notationally self-consistent and useful for the intended purpose.";


(* ::Input::Initialization:: *)
ExpectedTiming::usage = "?ExpectedTiming

ExpectedTiming[ t, x ]    evaluates  and returns the value of  x . As a side effect it also prints useful information about how long the evaluation took and when it was done.

The optional real argument  t  is an expected value (in seconds) for how long the computation should take (eg., obtained from a previous run).  

If  t  is present, then harmless warning messages are printed if  t  turns out to differ by more than  15%   from the measured timing.  These warnings are useful because significant timing changes can indicate something amiss.";


(* ::Input::Initialization:: *)
FnValueQ::usage="?FnValueQ

FnValueQ[ f[n] ]   tests if the function  f  has a value for the argument that results from evaluating  n.

Example:  Suppose we want to test if these have values:  f[1], f[2], f[3], ....  

We can do this test by:  ValueQ[ f[1] ], ValueQ[ f[2] ], ...   
but this method will not work within in a loop over  n   using  ValueQ[ f[n] ],  n = 1, 2, ...  
because then  f[n]  always has a value, ie., f[n] = f[1], f[2], ... .   

Such a loop over  n  will work using  FnValueQ[ f[n] ].  

FnValueQ[ f[n1, n2, ...] ]  works similarly.";


(* ::Input::Initialization:: *)
deg::usage="? \[VeryThinSpace]deg

deg\[VeryThinSpace][X]  returns the tensor degree of X  (0 for scalar, 1 for vector, ...).

Let  X  \[Element]  U \[CircleTimes] V \[CircleTimes] W \[CircleTimes] ....  where there are  r  vector space factors in the tensor product.  
Then  deg\[VeryThinSpace][X] =  r.

Note:  It is no longer the done thing to call this the rank of  X. The rank of a tensor nowadays 
means the smallest number of simple tensors (single term completely factorizable tensor products)
that are required to express X. It generalizes the rank of a matrix. For example, see:

   http://en.wikipedia.org/wiki/Tensor_(intrinsic_definition)   

The term 'order' is often used by others instead of 'degree'.

You can set the degree of any symbol/expression X to be r by doing deg\[VeryThinSpace][X] = r.  However, it is 
generally better to use  NewField\[VeryThinSpace][\[VeryThinSpace]r,\[VeryThinSpace]X\[VeryThinSpace]]  (which also does other things). So unless you are adding 
funtionality to the package, you will probably never need to use the  deg\[VeryThinSpace][]  function.

By default, if  X  is a sum then  deg[X]  will check that all terms in  X  have the same degree, 
and will complain if this is not the case. This can be slow if  X  is a sum of many 1000 terms.  
This check can turned of by setting   

      degFullCheck = False

in which case deg[X]  will return the degree of the first term in X. To restore degree 
checking, set degFullCheck = True.

See also:   ? NewConstant ,  ? NewField " ;


(* ::Input::Initialization:: *)
rank::usage=deg::usage;
order::usage=deg::usage;


(* ::Input::Initialization:: *)
degCheck::usage = "? degCheck

degCheck\[VeryThinSpace][ x ]   prints information about the tensor degrees of the variables used in x .

If you get an error message such as  ''Not all struts have well defined degree''  then 
degCheck\[VeryThinSpace][ x ]  can be used to find the variables in  x  that have not yet been declared. 

See also:  ? NewConstant ,  ? NewField ";


(* ::Input::Initialization:: *)
deg0Q::usage="degNQ[ \[VeryThinSpace]x ]  (where N = 0, 1, 2, 3, 4)  returns True if x is degree N and False otherwise.

degNQ[ \[VeryThinSpace]\!\(\*SubscriptBox[\(x\), \(1\)]\), \!\(\*SubscriptBox[\(x\), \(2\)]\), ... ]  returns True if all the  \!\(\*SubscriptBox[\(x\), \(i\)]\)  are degree N and False otherwise.

The functions deg0Q, deg1Q, deg2Q, deg3Q, deg4Q  are convenient for pattern matching arguments.  

For example :  f[ y_?deg0Q ]  is the same as  f[ y_/; deg[y] === 0 ] .";


(* ::Input::Initialization:: *)
deg1Q::usage=deg0Q::usage;
deg2Q::usage=deg0Q::usage;
deg3Q::usage=deg0Q::usage;
deg4Q::usage=deg0Q::usage;


(* ::Input::Initialization:: *)
FieldQ::usage="FieldQ[ X ]  returns True if  X  is a tensor field as declared by  NewField[ ],  and  False  otherwise.

( ClearField[ X ] ; FieldQ[ X ] )  returns False.

See also:  ? ConstantQ";


(* ::Input::Initialization:: *)
ConstantQ::usage="ConstantQ[ X ]  returns True if  X  is a constant as declared by  NewConstant[ ],  and  False  otherwise. 

Both of  ( ClearConstant[ X ] ; ConstantQ[ X ] )  and   ( ClearField[ X ] ; ConstantQ[ X ] )  return False.

See also:  ? ConstantQ";


(* ::Input::Initialization:: *)
NewConstant::usage = "?\[VeryThinSpace]NewConstant

NewConstant [ c1 ]  
NewConstant [ {c1 , c2, ...} ]  declares the symbols  c1,...  to be constants.  
NewConstant [ c ]   is equivalent to  ( deg [ c ] = 0 ;  \[Del] c = 0 ; ) ,  but will first check that  c  is not already in use, and ask what to do if it is.

See also:   ? NewField ,  ? ClearField ,  ? ClearConstant .";


(* ::Input::Initialization:: *)
NewField::usage="?\[VeryThinSpace]NewField

NewField [ r , f ] 
NewField [ r , {f1,...fn} ]   will introduce the degree relations (such as  deg [ f1 ] = r ),  that are needed for 
the (unassigned) symbols  f1, ... fn  to be treated as  r-tensor fields.  

NewField[ r , f]  is only useful for declaring new 'arbitrary' fields, not expressible in terms other tensor fields 
already in the system (in particular, there is no need to declare  f  before making assignments such as  f = u + v ,  
or  f = u \[CircleTimes] v ,  where u and v are tensor fields). 

Scalar fields are degree  r = 0 , vectors fields are degree  r = 1 , etc. 

To declare an indexed collection fields, or fields that have their coordinate dependence explicit, the name  f  can be 
a pattern of the form  f\[VeryThinSpace]\[VeryThinSpace][ __ ] ,  \!\(\*SubscriptBox[\(f\), \(_\)]\) ,   \!\(\*SubscriptBox[\(f\), \(__\)]\)[\[VeryThinSpace]_\[VeryThinSpace]] ,  f\[VeryThinSpace][\[VeryThinSpace]_\[VeryThinSpace]][\[VeryThinSpace]_\[VeryThinSpace]] ,  etc. 

(Tip: To avoid assignments to Subscript[ ], consider using Format[ ]) 

NewField [ r , f ]  will ask what to do if  f  already has a value, or if  f  is already declared as a field with
known tensor degree.  

See also:   ? NewConstant ,  ? ClearField ,  ? ClearConstant .";


(* ::Input::Initialization:: *)
ClearField::usage= "?\[VeryThinSpace]ClearField

ClearField [ f1 ] 
ClearField [ {f1,...,fn} ]  undoes everything done by  NewField [ ]  or  NewConstant [ ] ."; 
ClearConstant::usage= "?\[VeryThinSpace]ClearConstant 

ClearConstant [ c ]  is an alias for the function  ClearField [ c ].";


(* ::Input::Initialization:: *)
CircleTimes::usage = "?\[VeryThinSpace]CircleTimes

CircleTimes [ X , Y, . . . ]  \[Equal]  X \[CircleTimes] Y \[CircleTimes] . . .   is the tensor product.

Enter the symbol  \[CircleTimes]  by typing  [Esc] c* [Esc] .

Further info:  

In tpTensor,  Attributes[ CircleTimes ] = { Flat, Listable }

For reasons to do with easy list manipulation, CircleTimes[ ]  has been defined to be the identity if given only 
one argument:  CircleTimes [ X ] \[Equal] X   and   \[CircleTimes] X \[Equal] X .

CircleTimes[ ]  has been defined to collapse on scalars.  For example, if  deg [ a ] = 0   then   X \[CircleTimes] a \[CircleTimes] Y \[Equal]  a X \[CircleTimes] Y .

Output formating for  Times[ ]  has been modified so that tensor expressions are nicely printed, with the  CircleTimes[ ]  
factors appearing \!\(\*
StyleBox[\"after\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)their scalar coefficients.

Making  \[CircleTimes]  distributive over Plus was a bit messy  --  so at present is only coded for simplifying a maximum
of 8 tensor factors (you could add more code if you need more factors). If you know how to code the general case, 
please let me know. - ahn";


(* ::Input::Initialization:: *)
TensorPower::usage="TensorPower[ X, n ]  returns  X \[CircleTimes] ... \[CircleTimes] X,  with  n  factors of X.

TensorPower[ X, 0 ]  is defined to be  1.";


(* ::Input::Initialization:: *)
SimplifyTensor::usage="?\[VeryThinSpace]SimplifyTensor

SimplifyTensor [ X ]   is a better way to apply  Simplify [ ]  to tensor expressions. It is very much faster.

If  X  is a power-series (an expression with head SeriesData) then  SimplifyTensor[ ]  is applied to each coefficient in the series.
If  deg [ X ]  =  0 , then  SimplifyTensor [ X ]  is eqivalent to  Simplify [ X ] .

Additional information:

SimplifyTensor [ X ]   breaks up the problem of simplifying  X  into smaller pieces by separately applying  Simplify [ ]  to each 
'co-strut'  (defined below) of the tensor expression  X.  Tensor expressions for which  Simplify [ ]  will totally fail on because the 
expression  X  is too large, will sometimes simplify in just a few seconds.  

A co-strut of a tensor \!\(\*
StyleBox[\"expression\",\nFontSlant->\"Italic\"]\)  X  is a bit like a component --- it is the coefficient of a 'strut'.  The struts of  X  are the
elementary tensor products that appear in the expanded version of  X.  For example, the struts of the tensor expression
X  =  (3 + y) \[Eta] \[CircleTimes] a + 2 f (x) b \[CircleTimes] b \[CircleTimes] c ,  are   { \[Eta] \[CircleTimes] a ,  b \[CircleTimes] b \[CircleTimes] c } ,  and the co-struts are  { (3 + y) , 2 f (x) } .

Let V be the tensor-product vector space where X lives. Then the struts of X may or may not span the space V, and they may 
or may not be linearly independent as elements of V.  Nevertheless, the only way that the expression  X  can simplify (without 
introducing additional relations) is if the co-struts of  X  individually simplify.  So it is better to apply Simplify [ ]  to the co-struts 
of  X  than to  X  as a whole.

If all the struts of  X  are tensor products of basis vectors, then the co-struts of the expression  X  will include all of the non-zero 
components of the tensor  X  in that basis (and possibly also some components that simplify to zero).

All of the routines discussed here can be used with Clifford expressions (sums of terms with mixed degree).  

[The 'struts / co-struts' nomenclature is something I made up. Maybe there is something already established ? - ahn]  

See also:  struts [ X ] ,  costruts [ X ] ,  strutPair [ X ]";


(* ::Input::Initialization:: *)
struts::usage="?\[VeryThinSpace]struts

struts [ X ]   returns a sorted list of the struts of  X .  

For documentation on this function see:  ? SimplifyTensor

If  deg [ X ] = 0  then  struts [ X ] = { 1 }  and  costruts [ X ] = X .

See also:  costruts [ X ] ";


(* ::Input::Initialization:: *)
costruts::usage="?\[VeryThinSpace]costruts

costruts [ X ]   returns a list of the costruts of  X .  

For documentation on this function see:  ? SimplifyTensor

The order and length of the list returned by  costruts [ X ]  matches that returned by  struts [ X ] .
If  deg [ X ] = 0   then  struts [ X ] = { 1 }  and  costruts [ X ] = X .

See also:  struts [ X ] ";


(* ::Input::Initialization:: *)
strutPair::usage="?\[VeryThinSpace]strutPair

strutPair [ X ]  =  { struts [ X ] , costruts [ X ] } .  

This routine is provided because it is twice as fast as calling the above routines separately.
For documentation on this function see:  ? SimplifyTensor

The order and length of the list returned by  costruts [ X ]  matches that returned by  struts [ X ] .
If  deg [ X ] = 0   then  struts [ X ] = { 1 } .

See also:  struts [ X ] ,  costruts [ X ]";


(* ::Input::Initialization:: *)
ExpandTensor::usage="ExpandTensor[ X ]   or   X // ExpandTensor

Same as the function Expand, but optimized for tensor expressions X.

For more information, see:  ? SimplifyTensor";


(* ::Input::Initialization:: *)
ExpandAllTensor::usage="ExpandAllTensor[ X ]   or   X // ExpandAllTensor

Same as the function ExpandAll, but optimized for tensor expressions X.

For more information, see:  ? SimplifyTensor";


(* ::Input::Initialization:: *)
FullSimplifyTensor::usage="FullSimplifyTensor[ X ]   or   X // FullSimplifyTensor

Same as the function FullSimplify, but optimized for tensor expressions X.

For more information, see:  ? SimplifyTensor";


(* ::Input::Initialization:: *)
Del::usage= "?\[VeryThinSpace]Del

Del [ X ]  \[Equal]  \[Del] X    is the covariant gradient of the tensor expression  X .  
The gradient raises tensor degree by one:  deg\[VeryThinSpace][ \[Del] X ]  =  deg\[VeryThinSpace][ X ]  + 1. 

Usage:

\[Del]  is entered as  [Esc] del [Esc] .  
\[Del]  is a prefix operator,  so does not have square brackets  [  ]  around its argument.  
\[Del]  is the same as the function  Del [  ] , and can also be used in that form.

Attributes\[VeryThinSpace][ Del ] \[Equal] { Listable } ,  meaning that  \[Del]  will automatically  Thread\[VeryThinSpace][ ]  over lists. That is, \[Del]  will accept 
a list of tensors as its single argument and return a list with  \[Del]  applied to each list item.

\!\(\*
StyleBox[\"Further\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\" \",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\"information\",\nFontVariations->{\"Underline\"->True}]\)\!\(\*
StyleBox[\":\",\nFontVariations->{\"Underline\"->True}]\)

In  tpTensor  the covariant differential  \[Del]  is related to the covariant directional derivative  \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\)  by

                     \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\)Y  =  \[LeftAngleBracket] \[Del] Y , X \[RightAngleBracket]    \[LongLeftArrow] The tensor slot created by  \[Del]  appears as the \!\(\*
StyleBox[\"last\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"slot\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\) in  \[Del] Y , so as to conform 
                                                         to tensor index notation.  Thus,  X  appears to the right of  \[Del] Y  in the  \[LeftAngleBracket] , \[RightAngleBracket]  bracket.

Having   \[Del]  create slots on the right (rather than the left) is not the choice of many authors, but it is actually very sensible 
because it allows one to translate to/from component index notation \!\(\*
StyleBox[\"without\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"having\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"to\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"re\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"-\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"map\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"index\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"order\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\".\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)  It is how  \[Del]  is 
defined in\!\(\*
StyleBox[\"  \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"Gravitation\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"  \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)(Misner, Thorne & Wheeler)\!\(\*
StyleBox[\",\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontSlant->\"Italic\"]\)equation (8.17), page 208. 
 
To invert the above relation:  Let { \!\(\*SuperscriptBox[\(e\), \(i\)]\) }  be the covector (1-form) basis that is dual to the vector basis { \!\(\*SubscriptBox[\(e\), \(j\)]\) }, 
so that  \[LeftAngleBracket] \!\(\*SuperscriptBox[\(e\), \(i\)]\) , \!\(\*SubscriptBox[\(e\), \(j\)]\) \[RightAngleBracket] = \!\(\*SubscriptBox[SuperscriptBox[\(\[Delta]\), \(i\)], \(j\)]\)   and   \[Delta] =  \!\(\*SubscriptBox[SuperscriptBox[\(\[Delta]\), \(i\)], \(j\)]\) \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(\(j\)\(\\\ \\\ \)\)]\)  =  \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(\(i\)\(\\\ \\\ \)\)]\).  
Then,                             
                  \[Del] Y  =  \[LeftAngleBracket] \[Del] Y, \[Delta] \[RightAngleBracket]      
                         =  \[LeftAngleBracket] \[Del] Y, \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(i\)]\) \[RightAngleBracket]
                         =  \[LeftAngleBracket] \[Del] Y, \!\(\*SubscriptBox[\(e\), \(i\)]\) \[RightAngleBracket] \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(i\)]\)
                         =  \!\(\*SubscriptBox[\(\[Del]\), SubscriptBox[\(e\), \(i\)]]\)Y \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(i\)]\) ,

which would normally be taken as defining  \[Del] Y .  In  tpTensor  an entirely equivalent, but computationally simpler, definition of
\[Del] Y  is implemented which makes use of a braided Leibniz rule, as described below. 

While the directional derivative  \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\)  satisfies the Leibniz rule,

                              \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\) ( A \[CircleTimes] B )  =  \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\) A  \[CircleTimes]  B   +   A  \[CircleTimes]  \!\(\*SubscriptBox[\(\[Del]\), \(X\)]\) B ,
                                          
this is certainly  \!\(\*
StyleBox[\"not\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"the\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"case\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)  for the covariant differential, which must create its derivative slot as the \!\(\*
StyleBox[\"last\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\" \",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\)\!\(\*
StyleBox[\"slot\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\) (not stuck
somewhere in the middle of a tensor product, as in the expression  \[Del] A  \[CircleTimes] B ).  To move the derivative slot to its correct place, 
tpTensor evaluates  \[Del]  of any tensor product using the rule , 

                              \[Del] ( A \[CircleTimes] B )  =  mvToLast\[VeryThinSpace][ 1 + deg\[VeryThinSpace][ A ] , \[Del] A \[CircleTimes] B ]  +  A \[CircleTimes] \[Del] B .               [ See:  ?\[VeryThinSpace]\[VeryThinSpace]mvToLast ]

This is the 'braided Lebniz rule' referred to above, and it leads directly to the well known component expression for the 
covariant derivative in index notation. 

Example (1).  Let deg [ f ] = 0, and  X  be a tensor.  Then the above formula for  \[Del] ( A \[CircleTimes] B )  gives  \[Del] ( f X )  =  X \[CircleTimes] \[Del] f  +  f \[Del] X . 
If  tpTensor can not further evaluate either  \[Del] f  or  \[Del] X ,  then this is the expression that is returned. 
 
Example (2).  Suppose  X = \!\(\*SuperscriptBox[SubscriptBox[SuperscriptBox[\(X\), \(i\)], \(jk\)], \(pq\)]\) \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(j\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(k\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(p\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(q\)]\) ,  where the summations have been fully expanded out (because tpTensor 
does not understand Einstein summation convention).  Then  tpTensor  would return  \[Del] X  as the (rather large) fully expanded sum

                                 \[Del] X  =  \!\(\*SubscriptBox[SuperscriptBox[SubscriptBox[SuperscriptBox[\(X\), \(i\)], \(jk\)], \(pq\)], \(\(;\)\(\\\ \)\(r\)\)]\) \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(j\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(k\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(p\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(q\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(r\)]\) ,

where the set of components  \!\(\*SubscriptBox[SuperscriptBox[SubscriptBox[SuperscriptBox[\(X\), \(i\)], \(jk\)], \(pq\)], \(\(;\)\(\\\ \)\(r\)\)]\)  of  \[Del] X  is the usual 'covariant derivative' known from tensor index notation.  In particular, 
the notation and conventions used by  tpTensor  are such that any component  \!\(\*SubscriptBox[SuperscriptBox[SubscriptBox[SuperscriptBox[\(X\), \(i\)], \(jk\)], \(pq\)], \(\(;\)\(\\\ \)\(r\)\)]\)  of  \[Del] X  can be directly read off as the
coefficient of   \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(j\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(k\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(p\)]\) \[CircleTimes] \!\(\*SubscriptBox[\(e\), \(q\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(r\)]\)   in the expression for  \[Del] X ,  without the need to re-map index order. 

In example (2) it is presumed that one has already defined connection coefficients  \!\(\*SubscriptBox[SuperscriptBox[\(\[Omega]\), \(\(\\\ \)\(i\)\)], \(\(\\\ \)\(j\\\ k\)\)]\)  for the dual basis pair  { \!\(\*SubscriptBox[\(e\), \(i\)]\) , \!\(\*SuperscriptBox[\(e\), \(i\)]\) } , so that
tpTensor knows that it can evaluate  \[Del] \!\(\*SubscriptBox[\(e\), \(j\)]\)  and  \[Del] \!\(\*SuperscriptBox[\(e\), \(i\)]\)  as 

                                          \[Del] \!\(\*SubscriptBox[\(e\), \(j\)]\)  =     \!\(\*SuperscriptBox[\(\[Omega]\), \(\(\\\ \)\(i\)\)]\)\!\(\*SubscriptBox[\(\\\ \), \(j\\\ k\)]\)  \!\(\*SubscriptBox[\(e\), \(i\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(k\)]\) , 
                                          \[Del] \!\(\*SuperscriptBox[\(e\), \(i\)]\)  =  - \!\(\*SubscriptBox[SuperscriptBox[\(\[Omega]\), \(\(\\\ \)\(i\)\)], \(\(\\\ \)\(j\\\ k\)\)]\)  \!\(\*SuperscriptBox[\(e\), \(j\)]\) \[CircleTimes] \!\(\*SuperscriptBox[\(e\), \(k\)]\) . 

Furthermore, the index notation usually presumes working in a coordinate basis. So in example (2), one might suppose
that   { \!\(\*SubscriptBox[\(e\), \(i\)]\) , \!\(\*SuperscriptBox[\(e\), \(i\)]\) }  =  { \!\(\*SubscriptBox[\(\[PartialD]\), SuperscriptBox[\(x\), \(i\)]]\) , \!\(\*SuperscriptBox[\(dx\), \(\(i\)\(\\\ \\\ \)\)]\)} ,   in which case   \!\(\*SubscriptBox[SuperscriptBox[\(\[Omega]\), \(\(\\\ \)\(i\)\)], \(\(\\\ \)\(j\\\ k\)\)]\)  \[Equal]  \!\(\*SubscriptBox[SuperscriptBox[\(\[CapitalGamma]\), \(\(\\\ \)\(i\)\)], \(\(\\\ \)\(j\\\ k\)\)]\)   are the Christoffel symbols associated with { \!\(\*SuperscriptBox[\(x\), \(i\)]\) } coordinates.

tpTensor will calculate  \[Del]  in any frame,  using whatever information is available.  Thus, if  \[Del] \!\(\*SubscriptBox[\(e\), \(j\)]\)  and  \[Del] \!\(\*SuperscriptBox[\(e\), \(i\)]\)  had not yet been assigned
values, then factors of  \[Del] \!\(\*SubscriptBox[\(e\), \(j\)]\)  and  \[Del] \!\(\*SuperscriptBox[\(e\), \(i\)]\)  would have appeared explicitly in the result for  \[Del] X . 

See also :  ? mvToLast ,   ? connection";


(* ::Input::Initialization:: *)
gradient::usage = "?\[VeryThinSpace]gradient

For the operator  \[Del]\[ThinSpace],  see:   ? Del";


(* ::Input::Initialization:: *)
rev::usage="?\[VeryThinSpace]rev

rev [ X ]   reverses the product order of the (degree 1) factors in the tensor products that appear in  X .
Reversal generalizes the notion of transpose for a matrix. 

The following identity holds for tensors  A  and  B  of arbitrary degree,
           
                  rev [ A \[CircleTimes] B ]  =  rev [ B ] \[CircleTimes] rev [ A ] .

If  deg[ X ] = 0  (scalar),  or  deg[ X ] = 1  (vector),  then  rev[ X ] = X .

See also:   ? sym ,  ? alt ,  ? mvToLast";


(* ::Input::Initialization:: *)
mv::usage ="?\[VeryThinSpace]mv

mv[ n ][ X ]   returns the tensor obtained by rearranging slots of  X  into the arrangement specified by the sequence or list n.

Example:  Suppose  v1, v2, v3, v4, v5  are vectors.  Then  mv[ 3, 1, 2, 5, 4 ][ v1 \[CircleTimes] v2 \[CircleTimes] v3 \[CircleTimes] v4 \[CircleTimes] v5 ] = v3 \[CircleTimes] v1 \[CircleTimes] v2 \[CircleTimes] v5 \[CircleTimes] v4.

mv[ n ]  can be used as an operator. Eg,  mv[ 2, 1, 3 ][ mv[ 1, 3, 2 ] ]  evaluates to  mv[ 3, 1, 2 ].    

See also:  ? Sym, Alt, sym, alt, mvToLast " ;


(* ::Input::Initialization:: *)
mvInverse::usage="mvInverse[ n ]  evaluates to the mv[ ] operator that is inverse to  mv[ n ]." ;


(* ::Input::Initialization:: *)
mvToLast::usage ="?\[VeryThinSpace]mvToLast

mvToLast[ n , X ]   returns the tensor obtained by moving the nth slot of  X  to become the last slot of  X. 
mvToLast is a special case of  mv[ perm ][ X ]. 

Example:  Suppose  deg\[VeryThinSpace][ a ] = 2 ,  deg\[VeryThinSpace][ b ] = 1 ,   deg\[VeryThinSpace][ c ] = 3 .  Then  mvToLast\[VeryThinSpace][ 3 , a \[CircleTimes] b \[CircleTimes] c ] 
evaluates to  a \[CircleTimes] c \[CircleTimes] b ,  whereas  mvToLast\[VeryThinSpace][ 2 , a \[CircleTimes] b \[CircleTimes] c ]   remains un-simplified because slot 2 belongs 
to the factor  a,  so is 'stuck' where it is. 

mvToLast [ n , X ]  is a \!\(\*
StyleBox[\"braiding\",\nFontFamily->\"DejaVu Sans\",\nFontSlant->\"Italic\"]\) operator and is used to evaluate  \[Del]( X \[CircleTimes] Y ) by the braided Liebnitz rule.  
For further information see  ?\[VeryThinSpace]\[VeryThinSpace]\[VeryThinSpace]Del .  

See also:   ? Del " ;


(* ::Input::Initialization:: *)
mvSignature::usage="mvSignature[ n ]  returns  \[PlusMinus] 1,  according to the signature of the permutation corresponding to mv[ n ].

The argument  n  can be given as a list, sequence, or mv operator. ";


(* ::Input::Initialization:: *)
alt::usage = "?\[VeryThinSpace]alt

alt[ X ]   returns the alternating ( fully anti-symmetric ) part of X .

Example:   If  X = a \[CircleTimes] b \[CircleTimes] c   then  

         alt[ X ]  =  1/3!  ( a \[CircleTimes] b \[CircleTimes] c 
                                 - a \[CircleTimes] c \[CircleTimes] b 
                                 + c \[CircleTimes] a \[CircleTimes] b 
                                 - c \[CircleTimes] b \[CircleTimes] a 
                                 + b \[CircleTimes] c \[CircleTimes] a 
                                 - b \[CircleTimes] a \[CircleTimes] c ) 

[ Not well coded at the moment :  defined only for deg[ X ] \[LessEqual] 4 , left unevaluated otherwise. ] 

See also:   ? sym ,  ? rev";


(* ::Input::Initialization:: *)
dotprod::usage=AngleBracket::usage;


(* ::Input::Initialization:: *)
contraction::usage =AngleBracket::usage;


(* ::Input::Initialization:: *)
SeriesProduct::usage="? SeriesProduct

SeriesProduct\[VeryThinSpace][ s1 , s2 , p ]  returns the expanded product series  p\[VeryThinSpace][ s1, s2 ]\[VeryThinSpace]  provided at least 
one of  s1  or  s2  is a series.  Here  p[ , ]  is the product to be used.

If neither  s1  or  s2  is a series then  SeriesProduct\[VeryThinSpace][ s1 , s2 , p ]  returns unevaluated.

Eg.   Let    
                a = a0 + a1 \[CurlyEpsilon] + O\[VeryThinSpace][\[VeryThinSpace]\[CurlyEpsilon]\[VeryThinSpace]\!\(\*SuperscriptBox[\(]\), \(2\)]\)
                b = b0 + b1 \[CurlyEpsilon] + O\[VeryThinSpace][\[VeryThinSpace]\[CurlyEpsilon]\[VeryThinSpace]\!\(\*SuperscriptBox[\(]\), \(2\)]\)

      then  SeriesProduct [ a , b , p ]  returns  
      
                p\[VeryThinSpace][ a0 , b0 ]  +  ( p\[VeryThinSpace][ a0 , b1 ] + p\[VeryThinSpace][ a1 , b0 ] ) \[CurlyEpsilon]   +  O\[VeryThinSpace][\[VeryThinSpace]\[CurlyEpsilon]\[VeryThinSpace]\!\(\*SuperscriptBox[\(]\), \(2\)]\)
\[VeryThinSpace]
A typical user will never need this function. It is used internally to define series expansions 
for   \[LeftAngleBracket] s1 , s2 \[RightAngleBracket]  and   s1 \[CircleTimes] s2   (for  p = AngleBracket  and  p = CircleTimes  respectively ).

If  p = Times ,  then   SeriesProduct\[VeryThinSpace][ s1 , s2 , p ]   is the same as   s1\[VeryThinSpace]s2 .
";


(* ::Input::Initialization:: *)
div::usage = "?\[VeryThinSpace]div

div\[VeryThinSpace][ X ]   returns the divergence of  X ,  which is a tensor field of degree  deg\[VeryThinSpace][ X ] - 1 .  
Div is calculated by contracting on the last two slots of  \[Del] X ,

                                           div\[VeryThinSpace][ X ]  =  \[LeftAngleBracket] \[Del] X \[RightAngleBracket]\!\(\*SubscriptBox[\(\\\ \), \(deg\[VeryThinSpace][X]\\\ , \\\ \\\ deg\[VeryThinSpace][X]\\\  + \\\ 1\)]\)

div [ X ]  is defined only for deg [ X ] \[GreaterEqual] 1.

See also:   ? curl";


(* ::Input::Initialization:: *)
curl::usage = "?\[VeryThinSpace]curl

curl\[VeryThinSpace][ X ]   returns curl of  X ,  which is a tensor field of degree  deg\[VeryThinSpace][ X ] + 1 .  
Curl is calculated by anti-symmetrizing on the last two slots of  \[Del] X ,  with an included factor of  -2 ,

                                         curl\[VeryThinSpace][ X ]  =  mvToLast\[VeryThinSpace][ deg\[VeryThinSpace][X] ,  \[Del] X ]   -  \[Del] X .

curl [ X ]  is defined only for deg [ X ] \[GreaterEqual] 1.

Example:   If  A  is an electromagnetic vector potential,  then  F = curl\[VeryThinSpace][ A ]  is the corresponding electromagnetic field tensor.  

See also:   ? div";


(* ::Input::Initialization:: *)
TraceFreeSquare::usage="?\[VeryThinSpace]TraceFreeSquare

TraceFreeSquare[ F ]   can be used to calculate the electromagnetic stress-energy tensor. 

In SI units, the electromagnetic stress-energy tensor  T  is given by

                                                T =  1/\!\(\*SubscriptBox[\(\[Mu]\), \(0\)]\) TraceFreeSquare[ F ]

where  F  is the electromagnetic field tensor and   \!\(\*SubscriptBox[\(\[Mu]\), \(0\)]\) = 4\[Pi] \[Cross] \!\(\*SuperscriptBox[\(10\), \(\(\\\ \)\(-7\)\)]\)  \!\(\*SuperscriptBox[\(NA\), \(-2\)]\)  is the permability of vacuum (magnetic constant).  

For SI constants see   http://physics.nist.gov/cuu/Constants/index.html

For the definition of this function see:   ?? TraceFreeSquare 

See also:  ? curl ,  ? div ";


(* ::Input::Initialization:: *)
MinkowskiFrame::usage="MinkowskiFrame[ ''name'' ]   will introduce a pre-defined Minkowski frame, for which the brakets \[LeftAngleBracket] , \[RightAngleBracket] are known, and the base-symbol(s) 
for the frame has/have been 'symbolized', so that superscript index notation does not get confused with exponent notation.

Currently, ''name'' can be the character string  ''e''  or  ''\[CapitalEpsilon]'' 

THIS FUNCTION HAS BEEN REMOVED at V8.0.
";


(* ::Input::Initialization:: *)
mvRep::usage="mvRep[ g_Cycles ] is the mv operator corresponding to the permutation g, given in disjoint cycle form.";


(* ::Input::Initialization:: *)
mvSplit::usage ="mvSplit[ \!\(\*FormBox[\(\(mv\)\([\)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ], { p, q } ]  attempts to split the specified  mv[]  operator into a pair of  mv[] operators that 
that permute seperately the objects  \!\(\*SubscriptBox[\(a\), \(i\)]\)  and  \!\(\*SubscriptBox[\(b\), \(j\)]\)  in the list  { \!\(\*SubscriptBox[\(a\), \(1\)]\), \!\(\*SubscriptBox[\(a\), \(2\)]\), ..., \!\(\*SubscriptBox[\(a\), \(p\)]\), \!\(\*SubscriptBox[\(b\), \(1\)]\), \!\(\*SubscriptBox[\(b\), \(2\)]\), ..., \!\(\*SubscriptBox[\(b\), \(q\)]\) } .

mvSplit[ \!\(\*FormBox[\(\(mv\)\([\)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ], { p, q }  ] returns a list of length 3, having the form  {c, P, Q}  where c = 0, 1, or 2, and where 
(for c\[VeryThinSpace]\[NotEqual]\[VeryThinSpace]0)  P and Q  are mv[] operators. Let s  be the permuted vector
 
                                 s =  mv[ \!\(\*FormBox[SubscriptBox[\(n\), \(1\)],
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ][ { \!\(\*SubscriptBox[\(a\), \(1\)]\), \!\(\*SubscriptBox[\(a\), \(2\)]\), ..., \!\(\*SubscriptBox[\(a\), \(p\)]\) ,  \!\(\*SubscriptBox[\(b\), \(1\)]\), \!\(\*SubscriptBox[\(b\), \(2\)]\), ..., \!\(\*SubscriptBox[\(b\), \(q\)]\) } ] .
  
The returned value  c  identifies which of the following cases holds : 

         c = 0 :  The symbols  \!\(\*SubscriptBox[\(a\), \(i\)]\)  and  \!\(\*SubscriptBox[\(b\), \(j\)]\)  are mixed up in  s .  The  \!\(\*SubscriptBox[\(a\), \(i\)]\) are not all together (and neither are the \!\(\*SubscriptBox[\(b\), \(j\)]\)).   

         c = 1 :  All the symbols  \!\(\*SubscriptBox[\(a\), \(i\)]\)  appear first in  s, in which case for some  P = mv[ \!\(\*SubscriptBox[\(p\), \(1\)]\), \!\(\*SubscriptBox[\(p\), \(2\)]\), ...], and  Q = mv[ \!\(\*SubscriptBox[\(q\), \(1\)]\), \!\(\*SubscriptBox[\(q\), \(2\)]\), ...],  

                     s = Flatten[{ P[{ \!\(\*SubscriptBox[\(a\), \(1\)]\), \!\(\*SubscriptBox[\(a\), \(2\)]\), ..., \!\(\*SubscriptBox[\(a\), \(p\)]\) }], Q[{ \!\(\*SubscriptBox[\(b\), \(1\)]\), \!\(\*SubscriptBox[\(b\), \(2\)]\), ..., \!\(\*SubscriptBox[\(b\), \(q\)]\) }] }]. 

         c = 2 :  All the symbols  \!\(\*SubscriptBox[\(b\), \(j\)]\)  appear first in  s, in which case for some  P = mv[ \!\(\*SubscriptBox[\(p\), \(1\)]\), \!\(\*SubscriptBox[\(p\), \(2\)]\), ...], and  Q = mv[ \!\(\*SubscriptBox[\(q\), \(1\)]\), \!\(\*SubscriptBox[\(q\), \(2\)]\), ...],  

                     s = Flatten[{ Q[{ \!\(\*SubscriptBox[\(b\), \(1\)]\), \!\(\*SubscriptBox[\(b\), \(2\)]\), ..., \!\(\*SubscriptBox[\(b\), \(q\)]\) }], P[{ \!\(\*SubscriptBox[\(a\), \(1\)]\), \!\(\*SubscriptBox[\(a\), \(2\)]\), ..., \!\(\*SubscriptBox[\(a\), \(p\)]\) }] }]. 

For the case c = 0, the value returned by  mvSplit  is the list  { 0, { Null, Null} }.

The first argument of  mvSplit[ ]  can also be provided as the list  \!\(\*FormBox[\({\\\ \*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ...}  instead of the operator  \!\(\*FormBox[\(\(mv\)\([\)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ].";


(* ::Input::Initialization:: *)
mvSplitQ::usage ="mvSplitQ[ \!\(\*FormBox[\(\(mv\)\([\)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ..., \!\(\*SubscriptBox[\(n\), \(r\)]\)], { p, q } ]  returns True if the specified mv[] splits, and False otherwise.

It is assumed that  \!\(\*FormBox[\(\(mv\)\([\)\(\\\ \)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ]  is a valid mv[ ],  that is,  { \!\(\*SubscriptBox[\(n\), \(1\)]\), \!\(\*SubscriptBox[\(n\), \(\(2\)\(,\)\(\\\ \)\)]\)..., \!\(\*SubscriptBox[\(n\), \(r\)]\) } is a permutation of  { 1, 2, ..., r }.    

The first argument of  mvSplit[ ]  can also be provided as the list  \!\(\*FormBox[\({\\\ \*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ...}  instead of the operator  \!\(\*FormBox[\(\(mv\)\([\)\(\\\ \)\*SubscriptBox[\(n\), \(1\)]\),
TraditionalForm]\), \!\(\*FormBox[SubscriptBox[\(n\), \(2\)],
TraditionalForm]\), ... ].

For further info see:  ? mvSplit";


(* ::Input::Initialization:: *)
SetmvArgLengthFixed::usage="SetmvArgLengthFixed[ ]  will standardize the length of mv arguments according to tensor degree.

See also: SetmvArgLengthVariable[ ]";


(* ::Input::Initialization:: *)
SetmvArgLengthVariable::usage="SetmvArgLengthVariable[ ]  will make mv arguments as short as possible.

See also: SetmvArgLengthFixed[ ]";


(* ::Input::Initialization:: *)
sym::usage="sym[ \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\)]  \[Congruent] sym[ \!\(\*FormBox[\(\({\*SubscriptBox[\(n\), \(1\)], \\\ \*SubscriptBox[\(n\), \(2\)], \\\  ... \\\ }\)\(\\\ \)\),
TraditionalForm]\)]  is the mv operator for symmetrizing on tensor slots  \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\).

sym  acts on tensors as  sym[ \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\)][ X ] . 

sym[ ][ X ] denotes full symmetrization on all slots of  X. 

If possible, it is better to use unevaluated symmetrization, defined by  Sym[ n ][X].

See also: ? Sym , ? Alt , ? alt";


(* ::Input::Initialization:: *)
alt::usage="alt[ \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\)]  \[Congruent] alt[ \!\(\*FormBox[\(\({\*SubscriptBox[\(n\), \(1\)], \\\ \*SubscriptBox[\(n\), \(2\)], \\\  ... \\\ }\)\(\\\ \)\),
TraditionalForm]\)]  is the mv operator for anti-symmetrizing on tensor slots  \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\).

alt  acts on tensors as  alt[ \!\(\*FormBox[\(\*SubscriptBox[\(n\), \(1\)]\(,\)\(\\\ \)\*SubscriptBox[\(n\), \(2\)]\(,\)\(\\\ \)\(...\)\(\\\ \)\),
TraditionalForm]\)][ X ] . 

alt[ ][ X ] denotes full anti-symmetrization on all slots of  X. 

If possible, it is better to use unevaluated anti-symmetrization, defined by  Alt[ n ][X].

See also: ? Alt , ? Sym , ? sym";


(* ::Input::Initialization:: *)
AssumeSymmetric::usage="AssumeSymmetric[ X ]  or  AssumeSymmetric[ { \!\(\*SubscriptBox[\(X\), \(1\)]\) , \!\(\*SubscriptBox[\(X\), \(2\)]\) , ... } ]   

Use automatic simplifications rules that result from assuming that  X  is a fully symmetric tensor. 

See also:  ? ForgetAssumeSymmetric " ;


(* ::Input::Initialization:: *)
ForgetAssumeSymmetric::usage="ForgetAssumeSymmetric[ X ]  or  ForgetAssumeSymmetric[ { \!\(\*SubscriptBox[\(X\), \(1\)]\) , \!\(\*SubscriptBox[\(X\), \(2\)]\) , ... } ]   

Stop using simplifications rules that result from assuming that  X  is a fully symmetric tensor. 

See also:  ? AssumeSymmetric";


(* ::Input::Initialization:: *)
SymQ::usage="SymQ[ X ]  returns True if  X  is being assumed to be symmetric.

See also:  ? AssumeSymmetric ,  ? ForgetAssumeSymmetric";


(* ::Input::Initialization:: *)
AssumeAntisymmetric::usage="AssumeAntisymmetric[ X ]  or  AssumeAntisymmetric[ { \!\(\*SubscriptBox[\(X\), \(1\)]\) , \!\(\*SubscriptBox[\(X\), \(2\)]\) , ... } ]   

Use automatic simplifications rules that result from assuming that  X  is a fully antisymmetric tensor. 

See also:  ? ForgetAssumeAntisymmetric " ;


(* ::Input::Initialization:: *)
ForgetAssumeAntisymmetric::usage="ForgetAssumeAntisymmetric[ X ]  or  ForgetAssumeAntisymmetric[ { \!\(\*SubscriptBox[\(X\), \(1\)]\) , \!\(\*SubscriptBox[\(X\), \(2\)]\) , ... } ]   

Stop using simplifications rules that result from assuming that  X  is a fully antisymmetric tensor. 

See also:  ? AssumeAntisymmetric";


(* ::Input::Initialization:: *)
AntisymQ::usage="AntisymQ[ X ]  returns True if  X  is being assumed to be antisymmetric.

See also:  ? AssumeAntisymmetric ,  ? ForgetAssumeAntisymmetric";


(* ::Input::Initialization:: *)
EvaluateSym::usage="EvaluateSym[ expr ]   or   expr // EvaluateSym

EvaluateSym  replaces  Sym \[Rule] sym  to give an explicit evaluation of  expr  in terms of mv operators.  

See also:  ? sym , ? Sym , ? mv";


(* ::Input::Initialization:: *)
\[CurlyEpsilon]4::usage="\[CurlyEpsilon]4 is the 4-dimensional Levi-Civita tensor.

See also:  ? \[CurlyEpsilon]2,  ? \[CurlyEpsilon]3 ";


(* ::Input::Initialization:: *)
\[CurlyEpsilon]3::usage="\[CurlyEpsilon]3 is the 3-dimensional Levi-Civita tensor.

See also:  ? \[CurlyEpsilon]2,  ? \[CurlyEpsilon]4 ";


(* ::Input::Initialization:: *)
\[CurlyEpsilon]2::usage="\[CurlyEpsilon]2 is the 2-dimensional Levi-Civita tensor.

See also:  ? \[CurlyEpsilon]3,  ? \[CurlyEpsilon]4 ";


(* ::Input::Initialization:: *)
If[TrueQ[$PrintDebugLocation],Print["End of Part0"]]
SaveInitTime[]
