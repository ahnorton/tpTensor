(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Off[Syntax::bktwrn]


(* ::Input::Initialization:: *)
Off[General::bktwrn]


(* ::Input::Initialization:: *)
LastTimeUsed=TimeUsed[];
Clear[TimeLapsed]
TimeLapsed[x___]:=Module[{dt},
dt=TimeUsed[]-LastTimeUsed;
Print[dt," CPU seconds"];
If[!(x===PatternSequence[])&&dt>1.1x, Print["********* Slow Code Warning *********"]];
If[!(x===PatternSequence[])&&dt<0.9x, Print["********* Fast Code Warning *********"]];
LastTimeUsed=TimeUsed[];]


(* ::Input::Initialization:: *)
SetAttributes[ExpectedTiming,HoldAllComplete]
ExpectedTiming[x_]:=ExpectedTiming[0,x]
ExpectedTiming[s_,x_]:=Module[{t,r},
t=Timing[x];
r = Round[100 First[t]]/100//N;
Print[r,"\[VeryThinSpace]\[VeryThinSpace]\[VeryThinSpace]sec, at \[VeryThinSpace]\[VeryThinSpace]",DateString[{"Year","-","Month","-","Day"," ","Hour24",":","Minute"}],", tpTensorVer",$tpTensorVersion,"."];
If[s>10$TimeUnit,
If[r>1.15s,  Print["********* Warning: slower than expected *********"]];
If[r<s/1.15,Print["********* Warning: faster than expected *********"]]];t[[2]]]


(* ::Input::Initialization:: *)
SetAttributes[ExpectZero,HoldAll]
ExpectZero[z_]:=Module[{ans},
ans=z;
If[!ans===0,
Print["ExpectZero: The expression,"];
Print[HoldForm[z]];
Print["should evaluate to zero. Instead, it evaluates to:"]; 
Print[ans],
ans]]


(* ::Input::Initialization:: *)
ShortForm[x_,vars_List]:=Module[{f,vQ},
f=MemberQ[vars,#]&;
vQ=Apply[And,Map[f,{#}]]&;
HoldForm[x]/.{X_[s__?vQ]:>X,Derivative[j_][X_][s__?vQ]:>Derivative[j][X]}]


(* ::Input::Initialization:: *)
ShortForm[x_]:=ShortForm[x,{s,
\!\(\*OverscriptBox[\(s\), \(_\)]\)}]


(* ::Input::Initialization:: *)
Unprotect[TrigReduce];
TrigReduce[x_SeriesData]:=MapAt[TrigReduce,x,3]
Protect[TrigReduce];


(* ::Input::Initialization:: *)
Clear[DependsQ]
DependsQ[y_,x_]:=!FreeQ[y,x]


(* ::Input::Initialization:: *)
FnValueQ[f_[n__]]:=Module[{x},ReleaseHold[FlattenAt[ReplacePart[Hold[ValueQ[f[x]]],{1,1,1}->{n}],{1,1,1}]]]


(* ::Input::Initialization:: *)
PairQ[x_]:=Head[x]===List&&Length[x]===2


(* ::Input::Initialization:: *)
TakePlus[x_]:= x/.PlusMinus[a_]:>a/.PlusMinus[a_,b_]:>a+b/.PlusMinus[a_,b_,c__]:>PlusMinus[a+b,c]


(* ::Input::Initialization:: *)
TakeMinus[x_]:= x/.PlusMinus[a_]:>-a/.PlusMinus[a_,b_]:>a-b/.PlusMinus[a_,b_,c__]:>PlusMinus[a-b,c]


(* ::Input::Initialization:: *)
AddAssumption[a_]:=$Assumptions =DeleteDuplicates[$Assumptions&&a]


(* ::Input::Initialization:: *)
RemoveAssumption[a_]:=If[$Assumptions===a,$Assumptions =True,$Assumptions =DeleteCases[$Assumptions,a]]


(* ::Input::Initialization:: *)
RemoveAssumption[a_And]:=(Scan[RemoveAssumption,a];$Assumptions)


(* ::Input::Initialization:: *)
FormatSymbol[var_,rep_String]:=Module[{b,s1,s2},
b=ToString[FullForm[Apply[MakeBoxes,MakeExpression[rep,StandardForm]]]];
s1=SymbolName[var]<>"/:MakeBoxes["<>SymbolName[var]<>",StandardForm]:="<>b;
ToExpression[s1];
s2="MakeExpression["<>b<>",StandardForm]:=HoldComplete["<>SymbolName[var]<>"]";
ToExpression[s2];
Column[{s1,s2}]
]


(* ::Input::Initialization:: *)
UnformatSymbol[var_]:=Module[{b,s1,s2},
b=ToString[FullForm[MakeBoxes[var//DisplayForm][[1]]]];
s1=SymbolName[var]<>"/:MakeBoxes["<>SymbolName[var]<>",StandardForm]=.";
ToExpression[s1];
s2="MakeExpression["<>b<>",StandardForm]=.";
ToExpression[s2];
Column[{s1,s2}]
]


(* ::Input::Initialization:: *)
OverscriptSymbol[var_Symbol,under_String,over_String]:=Module[{b,s1,s2},
b="OverscriptBox[\""<>under<>"\",\""<>over<>"\"]";
s1=SymbolName[var]<>"/:MakeBoxes["<>SymbolName[var]<>",StandardForm]:="<>b;
ToExpression[s1];
s2="MakeExpression["<>b<>",StandardForm]:=HoldComplete["<>SymbolName[var]<>"]";
ToExpression[s2];
Column[{b,s1,s2}]
]


(* ::Input::Initialization:: *)
VecSymbol[var_Symbol,under_String]:=OverscriptSymbol[var,under,"\[RightArrow]"]


(* ::Input::Initialization:: *)
HatSymbol[var_Symbol,under_String]:=OverscriptSymbol[var,under,"^"]


(* ::Input::Initialization:: *)
BarSymbol[var_Symbol,under_String]:=OverscriptSymbol[var,under,"_"]


(* ::Input::Initialization:: *)
neg1space="\[NegativeVeryThinSpace]";
neg2space="\[NegativeThinSpace]";
neg3space="\[NegativeMediumSpace]";
neg4space="\[NegativeThickSpace]";


(* ::Input::Initialization:: *)
horizontalline[n_]:=StringRepeat["\[HorizontalLine]",n]


(* ::Input::Initialization:: *)
\[Lambda]barTagBox = TagBox[RowBox[{"\[Lambda]",neg4space,neg1space,AdjustmentBox[horizontalline[2],BoxBaselineShift->-0.93]}],"lambdabar"];


(* ::Input::Initialization:: *)
\[Lambda]bar0TagBox = TagBox[SubscriptBox[RowBox[{"\[Lambda]",neg4space,neg1space,AdjustmentBox[horizontalline[2],BoxBaselineShift->-0.93]}],"0"],"lambdabar0"];


(* ::Input::Initialization:: *)
\[Lambda]bareTagBox = TagBox[SubscriptBox[RowBox[{"\[Lambda]",neg4space,neg1space,AdjustmentBox[horizontalline[2],BoxBaselineShift->-0.93]}],"e"],"lambdabare"];


(* ::Input::Initialization:: *)
\[Lambda]bar\[Mu]TagBox = TagBox[SubscriptBox[RowBox[{"\[Lambda]",neg4space,neg1space,AdjustmentBox[horizontalline[2],BoxBaselineShift->-0.93]}],"\[Mu]"],"lambdabar\[Mu]"];


(* ::Input::Initialization:: *)
\[Lambda]barBTagBox = TagBox[SubscriptBox[RowBox[{"\[Lambda]",neg4space,neg1space,AdjustmentBox[horizontalline[2],BoxBaselineShift->-0.93]}],"B"],"lambdabarB"];


(* ::Input::Initialization:: *)
\[Lambda]bar/:MakeBoxes[\[Lambda]bar,StandardForm]:=\[Lambda]barTagBox


(* ::Input::Initialization:: *)
\[Lambda]bar0/:MakeBoxes[\[Lambda]bar0,StandardForm]:=\[Lambda]bar0TagBox


(* ::Input::Initialization:: *)
\[Lambda]bare/:MakeBoxes[\[Lambda]bare,StandardForm]:=\[Lambda]bareTagBox


(* ::Input::Initialization:: *)
\[Lambda]bar\[Mu]/:MakeBoxes[\[Lambda]bar\[Mu],StandardForm]:=\[Lambda]bar\[Mu]TagBox


(* ::Input::Initialization:: *)
\[Lambda]barB/:MakeBoxes[\[Lambda]barB,StandardForm]:=\[Lambda]barBTagBox


(* ::Input::Initialization:: *)
MakeExpression[\[Lambda]barTagBox,StandardForm]:=HoldComplete[\[Lambda]bar]


(* ::Input::Initialization:: *)
MakeExpression[\[Lambda]bar0TagBox,StandardForm]:=HoldComplete[\[Lambda]bar0]


(* ::Input::Initialization:: *)
MakeExpression[\[Lambda]bareTagBox,StandardForm]:=HoldComplete[\[Lambda]bare]


(* ::Input::Initialization:: *)
MakeExpression[\[Lambda]bar\[Mu]TagBox,StandardForm]:=HoldComplete[\[Lambda]bar\[Mu]]


(* ::Input::Initialization:: *)
MakeExpression[\[Lambda]barBTagBox,StandardForm]:=HoldComplete[\[Lambda]barB]


(* ::Input::Initialization:: *)
$ArgumentCheckingRuleNumbers={};
DoArgumentChecking[]:=(ResetRule[$ArgumentCheckingRuleNumbers];)
NoArgumentChecking[]:=(UnsetRule[$ArgumentCheckingRuleNumbers];)


(* ::Input::Initialization:: *)
ArgumentCheck[x_/;Head[x]===Defer[rule]]:=Module[{n},
n=First[x];
If[!MemberQ[$ArgumentCheckingRuleNumbers,n],AppendTo[$ArgumentCheckingRuleNumbers,n]];x]


(* ::Input::Initialization:: *)
UnsetRule[Defer[rule][n_]]:=UnsetRule[n]


(* ::Input::Initialization:: *)
ResetRule[Defer[rule][n_]]:=ResetRule[n]


(* ::Input::Initialization:: *)
Manifold[_]:=Manifold[]


(* ::Input::Initialization:: *)
Manifold[X_?FieldQ]:=First[FieldType[X]]


(* ::Input::Initialization:: *)
Manifold[\[Del]X_]:=Manifold[X]
Manifold[\[GothicCapitalD][X_]]:=Manifold[X]
Manifold[\[GothicCapitalD][X_,_]]:=Manifold[X]


(* ::Input::Initialization:: *)
Clear[NewManifold]
Manifold[]:="M";
$ListOfManifolds={"M"};


(* ::Input::Initialization:: *)
NewManifold[M_,n_]:=Module[{},
AppendTo[$ListOfManifolds,M];
$ListOfManifolds=DeleteDuplicates[$ListOfManifolds];
Manifold[]:=M;
dim[M]=n;]


(* ::Input::Initialization:: *)
NewManifold[M_,g_,{sigs__Integer}]:= Module[{},
AppendTo[$ListOfManifolds,M];
$ListOfManifolds=DeleteDuplicates[$ListOfManifolds];
Manifold[]:=M;
ClearMetric[];
NewMetric[g,{sigs}]]


(* ::Input::Initialization:: *)
NewManifold[M_,{g_,ginv_},{sigs__Integer}]:= Module[{},
AppendTo[$ListOfManifolds,M];
$ListOfManifolds=DeleteDuplicates[$ListOfManifolds];
Manifold[]:=M;
ClearMetric[];
NewMetric[M,{g,ginv},{sigs}]]


(* ::Input::Initialization:: *)
ProductSpace[{Vn__?PairQ}]:= CircleTimes[Apply[Sequence, Map[ProductSpace, {Vn}]]]


(* ::Input::Initialization:: *)
ProductSpace[{V_,1}]:=V
ProductSpace[{V_,n_}]:=
\!\(\*SuperscriptBox[\(V\), \("\<\[VeryThinSpace]\[CircleTimes]\>" <> ToString[n]\)]\)


(* ::Input::Initialization:: *)
Format[Tangent[M_],StandardForm]:="T"[M]
Format[Cotangent[M_],StandardForm]:="\!\(\*SuperscriptBox[\(T\), \(\(\[VeryThinSpace]\)\(*\)\)]\)\[NegativeThinSpace]"[M]


(* ::Input::Initialization:: *)
Format[Tangent[M_,p_],StandardForm]:=Subscript["T", p][M]
Format[Cotangent[M_,p_],StandardForm]:=\!\(
\(\*SubsuperscriptBox[\("\<T\>"\), \(p\), \("\<\[VeryThinSpace]*\>"\)]\)[M]\)


(* ::Input::Initialization:: *)
Format[Forms[V_,k_],StandardForm]:=Prefix[Forms[V],("\[CapitalLambda]")^ToString[k]]


(* ::Input::Initialization:: *)
DefaultVectorBundle[1]:=Tangent[Manifold[]]
DefaultVectorBundle[2]:=Cotangent[Manifold[]]
DefaultVectorBundle[n_]:=DefaultVectorBundle[1+Mod[n-1,2]]


(* ::Input::Initialization:: *)
TotalSpace[{n__}]:=Module[{t},
t=DeleteCases[MapIndexed[ {DefaultVectorBundle[First[#2]],#1}&, {n}],{_,0}];
If[t==={},{{Tangent[Manifold[]],0}},t]]


(* ::Input::Initialization:: *)
FieldType[\[GothicCapitalD][X_]]:= FieldType[X]


(* ::Input::Initialization:: *)
FieldType[\[Del]X_]:= Module[{M,t,n},
M=First[FieldType[X]];
t=FieldType[X][[2]];
If[MatchQ[Last[t],{Cotangent[M],n_}],
n=Last[Last[t]];
{M,Append[Most[t],{Cotangent[M],n+1}]},
{M,Append[t,{Cotangent[M],1}]}]]


(* ::Input::Initialization:: *)
FieldType[grad[X_]]:= Module[{M,t,n},
M=First[FieldType[X]];
t=FieldType[X][[2]];
If[MatchQ[Last[t],{Tangent[M],n_}],
n=Last[Last[t]];{M,Append[Most[t],{Tangent[M],n+1}]},
{M,Append[t,{Tangent[M],1}]}]]


(* ::Input::Initialization:: *)
FieldType[pD[X_,__]]:= FieldType[X]


(* ::Input::Initialization:: *)
FieldType[_]:="FieldType[\[MediumSpace]] is an enquiry function defined only for declared fields."


(* ::Input::Initialization:: *)
$RecursionLimit=1024;


(* ::Input::Initialization:: *)
SetAttributes[deg,Listable]


(* ::Input::Initialization:: *)
deg[]=0;


(* ::Input::Initialization:: *)
deg[c_?NumericQ]:=0
deg[expr_Times]:=Apply[Plus,Map[deg,Apply[List,expr]]]
deg[expr_CircleTimes]:=Apply[Plus,Map[deg,Apply[List,expr]]]


(* ::Input::Initialization:: *)
deg[X_Plus]:=Module[{d},
d=Union[deg[Apply[List,X]]];
If[Length[d]===1,First[d],d]]


(* ::Input::Initialization:: *)
deg[X__/;Length[{X}]>1]:=Apply[Plus,Map[deg,{X}]]


(* ::Input::Initialization:: *)
SetAttributes[{deg0Q,deg1Q,deg2Q,deg3Q,deg4Q},Listable]


(* ::Input::Initialization:: *)
deg0Q[x_]:=deg[x]===0
deg1Q[x_]:=deg[x]===1
deg2Q[x_]:=deg[x]===2
deg3Q[x_]:=deg[x]===3
deg4Q[x_]:=deg[x]===4
deg5Q[x_]:=deg[x]===5
deg6Q[x_]:=deg[x]===6
deg7Q[x_]:=deg[x]===7
deg8Q[x_]:=deg[x]===8


(* ::Input::Initialization:: *)
deg0Q[x__]:=Apply[SameQ,Prepend[deg[{x}],0]]
deg1Q[x__]:=Apply[SameQ,Prepend[deg[{x}],1]]
deg2Q[x__]:=Apply[SameQ,Prepend[deg[{x}],2]]
deg3Q[x__]:=Apply[SameQ,Prepend[deg[{x}],3]]
deg4Q[x__]:=Apply[SameQ,Prepend[deg[{x}],4]]
deg5Q[x__]:=Apply[SameQ,Prepend[deg[{x}],5]]
deg6Q[x__]:=Apply[SameQ,Prepend[deg[{x}],6]]
deg7Q[x__]:=Apply[SameQ,Prepend[deg[{x}],7]]
deg8Q[x__]:=Apply[SameQ,Prepend[deg[{x}],8]]


(* ::Input::Initialization:: *)
SetAttributes[{Same0or1Q,deg0or1Q},Listable]


(* ::Input::Initialization:: *)
Same0or1Q[x_]:=(x===0)||(x===1)
deg0or1Q[x_]:= Same0or1Q[deg[x]]
deg0or1Q[x__]:=Apply[And,Map[Same0or1Q,deg[{x}]]]


(* ::Input::Initialization:: *)
SetAttributes[{Same1or2Q,deg1or2Q},Listable]


(* ::Input::Initialization:: *)
Same1or2Q[x_]:=(x===2)||(x===1)
deg1or2Q[x_]:= Same1or2Q[deg[x]]
deg1or2Q[x__]:=Apply[And,Map[Same1or2Q,deg[{x}]]]


(* ::Input::Initialization:: *)
deg[rev[x_]]:=deg[x]


(* ::Input::Initialization:: *)
deg[a_^n_]/;deg0Q[a]:=0


(* ::Input::Initialization:: *)
deg[x_Plus/;degChecking]:= Module[{ok},
ok=Apply[SameQ,deg[Apply[List,x]]];
If[ok,
deg[First[x]],
Print["Indeterminate tensor degree. Set degChecking\[VeryThinSpace]\[VeryThinSpace]=\[VeryThinSpace]\[VeryThinSpace]False to turn off this degree check."];
Print["Output from degCheck[\[VeryThinSpace]_\[VeryThinSpace]] follows,"];
degCheck[x];
Abort[]]]


(* ::Input::Initialization:: *)
degCheck[x_]:=Module[{vars},
vars=Variables[x]//Sort;
Print[{vars,deg[vars]}//Transpose//MatrixForm]]


(* ::Input::Initialization:: *)
deg[deg[_]]:=0
deg[_?deg0Q!]:=0


(* ::Input::Initialization:: *)
deg[dim[_]]:=0


(* ::Input::Initialization:: *)
deg[Sin[f_?deg0Q]]:=0
deg[Cos[f_?deg0Q]]:=0
deg[Sec[f_?deg0Q]]:=0
deg[Csc[f_?deg0Q]]:=0
deg[Tan[f_?deg0Q]]:=0
deg[Cot[f_?deg0Q]]:=0
deg[Exp[f_?deg0Q]]:=0
deg[Log[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[Sinh[f_?deg0Q]]:=0
deg[Cosh[f_?deg0Q]]:=0
deg[Tanh[f_?deg0Q]]:=0
deg[Coth[f_?deg0Q]]:=0
deg[Sech[f_?deg0Q]]:=0
deg[Csch[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[ArcSin[f_?deg0Q]]:=0
deg[ArcCos[f_?deg0Q]]:=0
deg[ArcSec[f_?deg0Q]]:=0
deg[ArcCsc[f_?deg0Q]]:=0
deg[ArcTan[f_?deg0Q]]:=0
deg[ArcCot[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[ArcSinh[f_?deg0Q]]:=0
deg[ArcCosh[f_?deg0Q]]:=0
deg[ArcTanh[f_?deg0Q]]:=0
deg[ArcCoth[f_?deg0Q]]:=0
deg[ArcSech[f_?deg0Q]]:=0
deg[ArcCsch[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[Floor[f_?deg0Q]]:=0
deg[Ceiling[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[Sign[_]]:=0


(* ::Input::Initialization:: *)
deg[Abs[f_?deg0Q]]:=0


(* ::Input::Initialization:: *)
deg[Integrate[X_?deg0Q,__]]:=deg[X]


(* ::Input::Initialization:: *)
deg[X_SeriesData]:=If[X[[3]]==={},0,deg[X[[3,1]]]]


(* ::Input::Initialization:: *)
deg[Derivative[__][f_][__]]:=deg[f]


(* ::Input::Initialization:: *)
deg[Derivative[__][f_]]:=deg[f]


(* ::Input::Initialization:: *)
$ListOfFields={};
$ListOfConstants={};
ListOfFields[]:=$ListOfFields
ListOfConstants[]:=$ListOfConstants


(* ::Input::Initialization:: *)
ListOfFields[M_]:= Cases[ListOfFields[],M,Infinity]
ListOfConstants[M_]:= Cases[ListOfConstants[],M,Infinity]


(* ::Input::Initialization:: *)
Attributes[NewConstant]={HoldAll};
NewConstant[c_/;!Head[c]===List]:=Module[{ans,message},
If [MatchQ[AnyThingAtAll,c],Return["Error: The identifier matches an arbitrary name." ]];
If[ValueQ[deg[c]]||ValueQ[c],
message=If[ValueQ[c],
"Identifier  "<>ToString[Unevaluated[c]]<>"  is already in use (has a value).\n",""];
message=message<>If[ValueQ[deg[c]]&&!(deg[c]===0),
"Identifier  "<>ToString[Unevaluated[c]]<>"  is defined as a tensor field.\n"<>
"Currently  deg[ "<>ToString[Unevaluated[c]]<>" ] = "<>ToString[Short[deg[c]]]<>".\n\n",""];
message=message<>If[(\[Del]c===0),"Identifier  "<>ToString[Unevaluated[c]]<>"  is already defined as a constant.\n\n",""];
message=message<>"To re-defined  "<>ToString[Unevaluated[c]]<>"  as a constant, click OK.\n\n";
message=message<>"ClearField[ ] can be used to avoid this dialog.";
ans=ChoiceDialog[message];
If[!ans,Print["Cancelled in dialog: No changes made to ",Unevaluated[c],"."];Return[]];];
If[ValueQ[Unevaluated[c]],Unevaluated[c]=.];
ClearField[Unevaluated[c]];
FieldType[c]="constant";
Evaluate[If[Head[c]===Symbol,c,Head[c]]]/:deg[c]=0;
\[Del]c=0;
\[GothicCapitalD][c]=0;
pD[c,__]=0;
ConstantQ[c]=True;
AppendTo[$ListOfConstants,c];
]


(* ::Input::Initialization:: *)
NewConstant[c_List]:= (Map[NewConstant,c];Null)


(* ::Input::Initialization:: *)
Attributes[NewField]={HoldAll};
NewField[base_,total_,f_/;!Head[f]===List]:=Module[{t,ans,message,r,msg},
If [MatchQ[AnyThingAtAll,f],Return["Error: The identifier matches an arbitrary name." ]];
If[ValueQ[deg[f]]||ValueQ[f],
message=If[ValueQ[f],
"The identifier  "<>ToString[Unevaluated[f]]<>"  is already in use (has a value).\n","The identifier  "<>ToString[Unevaluated[f]]<>"  is already in use.\n"];
message=message<>"Currently  deg[ "<>ToString[Unevaluated[f]]<>" ] = "<>ToString[Short[deg[f]]]<>".\n\n"<>"To re-defined  "<>ToString[Unevaluated[f]]<>"  click OK.";
message=message<>"\n\n"<>"ClearField[ ] can be used to avoid this dialog.";
ans=ChoiceDialog[message];
If[!ans,
Print["Cancelled in dialog: No changes made to ",Unevaluated[f],"."];Return[]
];
];
If[ValueQ[Unevaluated[f]],Unevaluated[f]=.];
ClearField[Unevaluated[f]];
Evaluate[If[Head[f]===Symbol,f,Head[f]]]/:deg[f]=Total[Map[#[[2]]&,total]];
FieldQ[f]=True;
SlotType[f]=Apply[SlotData,Flatten[Map[Table[#[[1]],{#[[2]]}]&,total]]];
FieldType[f]={base,total};
AppendTo[$ListOfFields,{f,FieldType[f]}];
msg =Row[{f," is a section of the tensor bundle ", ProductSpace[total]," over ",base,"."}];
If[MatchQ[total,{{Cotangent[base],1}}],msg=Row[{f," is a section of the cotangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],1}}],msg=Row[{f," is a section of the tangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],0}}],msg=Row[{f," is a scalar field on ",base,"."}]];
msg
]


(* ::Input::Initialization:: *)
NewField[base_,total_,f_List]:= Module[{msg,f1},
Map[NewField[base,total,#]&,f];
If[Length[f]===1,
f1=First[f];
msg =Row[{f," is a section of the tensor bundle ", ProductSpace[total]," over ",base,"."}];
If[MatchQ[total,{{Cotangent[base],1}}],msg=Row[{f1," is a section of the cotangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],1}}],msg=Row[{f1," is a section of the tangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],0}}],msg=Row[{f1," is a scalar field on ",base,"."}]]
,
msg =Row[{f," are declared sections of the tensor bundle ", ProductSpace[total]," over ",base,"."}];
If[MatchQ[total,{{Cotangent[base],1}}],msg=Row[{f," are sections of the cotangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],1}}],msg=Row[{f," are sections of the tangent bundle ", ProductSpace[total],"."}]];
If[MatchQ[total,{{Tangent[base],0}}],msg=Row[{f," are scalar fields on ",base,"."}]];
msg]
]


(* ::Input::Initialization:: *)
NewField[n_List,f_]:=NewField[Manifold[],TotalSpace[n],f]


(* ::Input::Initialization:: *)
NewField[n_Integer,f_]:=NewField[{n},f]


(* ::Input::Initialization:: *)
Attributes[ClearField]={HoldAll};
ClearField[f_/;!Head[f]===List]:=Module[{},
If [MatchQ[AnyThingAtAll,f],Print["Error: The identifier matches an arbitrary symbol. Maybe subscript-underscore miss-typed as underscore?" ];Abort[]];
If[ValueQ[f],f=.];
Quiet[If[ValueQ[deg[f]],deg[f]=.]]; 
If[ValueQ[deg[f]],Evaluate[If[Head[f]===Symbol,f,Head[f]]]/:deg[f]=.];
If[ValueQ[\[Del]f],\[Del]f=.];
If[ValueQ[\[GothicCapitalD][f]],\[GothicCapitalD][f]=.];
If[ValueQ[pD[f,__]],pD[f,__]=.];
ForgetAssumeSymmetric[f];
ForgetAssumeAntisymmetric[f];
Quiet[(FieldQ[f]=.;ConstantQ[f]=.;)];
$ListOfConstants=DeleteCases[$ListOfConstants,f];
$ListOfFields=DeleteCases[$ListOfFields,f];
Quiet[FieldType[f]=.;];
Quiet[SlotType[f]=.;];
]


(* ::Input::Initialization:: *)
ClearField[f_List]:= (ReleaseHold[Map[ClearField,Hold[f],{2}]];)


(* ::Input::Initialization:: *)
ClearConstant=ClearField;


(* ::Input::Initialization:: *)
Format[SlotData[X___],StandardForm]:={X}


(* ::Input::Initialization:: *)
SetAttributes[SlotData,Flat]


(* ::Input::Initialization:: *)
SlotType[X1_,X2__]:= Map[SlotType,SlotData[X1,X2]]


(* ::Input::Initialization:: *)
SlotType[X_CircleTimes]:= Map[SlotType,Apply[SlotData,X]]


(* ::Input::Initialization:: *)
DropFirst[x_SlotData]/;!Head[First[x]]===SlotType:=Rest[x]
DropLast[x_SlotData]/;!Head[Last[x]]===SlotType:=Most[x]
DropFirstAndLast[x_SlotData]/;!Head[First[x]]===SlotType:=DropLast[Rest[x]]
DropFirstAndLast[x_SlotData]/;!Head[Last[x]]===SlotType:=DropFirst[Most[x]]


(* ::Input::Initialization:: *)
SlotType[\[LeftAngleBracket]X1_,X2_\[RightAngleBracket]]:=SlotData[DropLast[SlotType[X1]],DropFirst[SlotType[X2]]]


(* ::Input::Initialization:: *)
SlotType[\[LeftAngleBracket]X1_,X2_,X3_\[RightAngleBracket]]:=SlotData[DropLast[SlotType[X1]],DropFirstAndLast[SlotType[X2]],DropFirst[SlotType[X3]]]


(* ::Input::Initialization:: *)
SlotType[\[LeftAngleBracket]X1_,X2__,X3_,X4_\[RightAngleBracket]]:=SlotData[DropLast[SlotType[X1]],DropFirstAndLast[SlotType[\[LeftAngleBracket]X2,X3\[RightAngleBracket]]],DropFirst[SlotType[X4]]]


(* ::Input::Initialization:: *)
SlotType[X_Plus]:=SlotType[First[X]]


(* ::Input::Initialization:: *)
SlotType[X_SeriesData/;!X[[3]]==={}]:=SlotType[X[[3,1]]]


(* ::Input::Initialization:: *)
SlotType[a_?deg0Q  X_]:=SlotType[X]


(* ::Input::Initialization:: *)
SlotType[X_?deg0Q]:=SlotData[]


(* ::Input::Initialization:: *)
SlotType[mv[n__][X_]]:=mv[n][SlotType[X]]


(* ::Input::Initialization:: *)
NotSlotTypeQ[x_]:=!Head[x]===SlotType


(* ::Input::Initialization:: *)
mv[n__][SlotData[x__?NotSlotTypeQ]]:=Apply[SlotData,mv[n][{x}]]


(* ::Input::Initialization:: *)
SlotType[rev[X_]]:=rev[SlotType[X]]


(* ::Input::Initialization:: *)
rev[s_SlotData]:=Map[rev,Reverse[s]]


(* ::Input::Initialization:: *)
rev[x_Tangent]:=x
rev[x_Cotangent]:=x


(* ::Input::Initialization:: *)
SlotType[\[Del]X_?FieldLikeQ]:=Append[SlotType[X],Cotangent[Manifold[]]]


(* ::Input::Initialization:: *)
SlotType[grad[X_?FieldLikeQ]]:=Append[SlotType[X],Tangent[Manifold[]]]


(* ::Input::Initialization:: *)
SlotType[\[GothicCapitalD][X_?FieldLikeQ]]:=SlotType[X]


(* ::Input::Initialization:: *)
SlotType[\[GothicCapitalD][X_?FieldLikeQ,_]]:=SlotType[X]


(* ::Input::Initialization:: *)
SlotType[pD[X_?FieldLikeQ,__]]:=SlotType[X]


(* ::Input::Initialization:: *)
SlotType[Derivative[__][X_?FieldLikeQ]]:=SlotType[X]


(* ::Input::Initialization:: *)
SlotType[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__]]:=Delete[SlotType[X],Map[List,Flatten[{ab}]]]


(* ::Input::Initialization:: *)
SlotType[0]:=SlotType[$ZeroTensor]


(* ::Input::Initialization:: *)
FieldQ[x_]:=False
ConstantQ[x_]:=False


(* ::Input::Initialization:: *)
FieldQ[x__]:= Apply[And,Map[FieldQ,{x}]]


(* ::Input::Initialization:: *)
DerivedFieldQ[_]:=False


(* ::Input::Initialization:: *)
DerivedFieldQ[\[Del]_]:=True
DerivedFieldQ[Derivative[__][_]]:=True
DerivedFieldQ[Derivative[__][_][_]]:=True
DerivedFieldQ[_\[GothicCapitalD]]:=True
DerivedFieldQ[_pD]:=True


(* ::Input::Initialization:: *)
DerivedFieldQ[x__]:= Apply[And,Map[DerivedFieldQ,{x}]]


(* ::Input::Initialization:: *)
FieldLikeQ[x_]:=FieldQ[x]||DerivedFieldQ[x]


(* ::Input::Initialization:: *)
FieldLikeQ[x__]:= Apply[And,Map[FieldLikeQ,{x}]]


(* ::Input::Initialization:: *)
AddRule[0,CircleTimes[v_]:=v]


(* ::Input::Initialization:: *)
AddRule[0,{}\[CircleTimes]X_:=X]
AddRule[0,X_\[CircleTimes]{}:=X]


(* ::Input::Initialization:: *)
AddRule[0,CircleTimes[a___, CircleTimes[b___, c___], d___]   :=   CircleTimes[a, b, c, d]]


(* ::Input::Initialization:: *)
AddRule[0,CircleTimes[v1___,a_?deg0Q,v2___]:=a CircleTimes[v1,v2]]


(* ::Input::Initialization:: *)
AddRule[0,u___\[CircleTimes]v_Plus\[CircleTimes]w___:=Map[CircleTimes[u,#,w]&,v]]


(* ::Input::Initialization:: *)
AddRule[0,CircleTimes[v1___,(a_?deg0Q) v2_,v3___]:=a CircleTimes[v1,v2,v3]]


(* ::Input::Initialization:: *)
TensorPower[_,0]:= 1
TensorPower[0,0]:= (Print["TensorPower[0,0] is indeterminate."];Abort[])
TensorPower[X_,1]:= X
TensorPower[X_,n_Integer]:= Apply[CircleTimes,Table[X,{n}]]


(* ::Input::Initialization:: *)
deg[TensorPower[X_,n_]]:=n deg[X]


(* ::Input::Initialization:: *)
CircleTimes[x_List,y__List]:=Outer[CircleTimes,x,y]


(* ::Input::Initialization:: *)
NotListQ[x_]:=!Head[x]===List


(* ::Input::Initialization:: *)
CircleTimes[z1___,x_?NotListQ,y__List,z2___]:=Map[CircleTimes[z1,x,#,z2]&,y]


(* ::Input::Initialization:: *)
CircleTimes[z1___,y__List,x_?NotListQ,z2___]:=Map[CircleTimes[z1,#,x,z2]&,y]


(* ::Input::Initialization:: *)
TensorForm[X_]:=Module[{n,s},
n=ArrayDepth[X];
If[OddQ[n],
s=Flatten[Prepend[Table[{3.5,2},{(n-1)/2}],{0,2}]];
MatrixForm[{X},TableSpacing->s]
,
s=Flatten[Table[{3.5,2},{n/2}]];
MatrixForm[X,TableSpacing->s]
]
]


(* ::Input::Initialization:: *)
MakeTensor[components_,tensorbasis_]:= Module[{},
If[!Dimensions[components]===Dimensions[tensorbasis],
Print["MakeTensor: Miss-matched array shapes for components and tensor basis."];
Print["Components = "];
Print[TensorForm[components]];
Print["Tensor basis = "];
Print[TensorForm[tensorbasis]];
Abort[],
Total[components tensorbasis,Infinity]
]
]


(* ::Input::Initialization:: *)
AddRule[0,rev[x_List]:= Map[rev,Reverse[x]]]


(* ::Input::Initialization:: *)
rev[]:=Sequence[]
AddRule[0,rev[X1_,X2__]:=Apply[Sequence,Map[rev,Reverse[{X1,X2}]]]]


(* ::Input::Initialization:: *)
AddRule[0,rev[expr_Plus]:=Map[rev,expr]]
AddRule[0,rev[expr_Times]:=Map[rev,expr]]


(* ::Input::Initialization:: *)
AddRule[0,rev[x_CircleTimes]:=CircleTimes[Apply[rev,x]]]


(* ::Input::Initialization:: *)
AddRule[0,rev[rev[X_]]:=X]


(* ::Input::Initialization:: *)
AddRule[0,rev[f_/;NumericQ[f]]:=f]


(* ::Input::Initialization:: *)
AddRule[0,rev[f_/;ConstantQ[f]]:=f]


(* ::Input::Initialization:: *)
revSignAntisym[r_Integer]:=If[OddQ[Floor[r/2]],-1,1]


(* ::Input::Initialization:: *)
AddRule[0,rev[f_?deg0or1Q]:=f]


(* ::Input::Initialization:: *)
revEvenQ[_]:=False
revOddQ[_]:=False
revEvenQ[__]:=False
revOddQ[__]:=False
AddRule[0,revEvenQ[x_/;SymQ[x]||(AntisymQ[x]&&EvenQ[Floor[deg[x]/2]])]:=True]
AddRule[0,revOddQ[x_/;AntisymQ[x]&&OddQ[Floor[deg[x]/2]]]:=True]


(* ::Input::Initialization:: *)
AddRule[ParityQ[X_,Y_]:=X===Y||X===-Y]
AddRule[ParityQ[X_List,Y_List]:=MapThread[ParityQ,{X,Y}]]


(* ::Input::Initialization:: *)
Clear[$UndefinedParity]
Protect[$UndefinedParity];
AddRule[Parity[x_,y_]:=If[x===y,1,If[x===-y,-1,$UndefinedParity]]]
AddRule[Parity[x_List,y_List]:= MapThread[Parity,{x,y}]]


(* ::Input::Initialization:: *)
AddRule[revEvenQ[X__/;Length[{X}]>1&&Apply[And,ParityQ[{X},rev[{X}]]]&&Apply[Times,Parity[{X},rev[{X}]]]===1]:=True]
AddRule[revOddQ[X__/;Length[{X}]>1&&Apply[And,ParityQ[{X},rev[{X}]]]&&Apply[Times,Parity[{X},rev[{X}]]]===-1]:=True]


(* ::Input::Initialization:: *)
degBracket[a__]:=deg[a]-2 (Length[{a}]-1)


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]X_?deg1Q,Y1__?deg2Q,Z_/;(deg2Q[Z]&&AntisymQ[Z])||(deg3Q[Z]&&revOddQ[Z]),Y2__,X_\[RightAngleBracket]/;Length[{Y1}]===Length[{Y2}]&&Apply[And,ParityQ[{Y1},rev[{Y2}]]]:=0]


(* ::Input::Initialization:: *)
deg2revParityQ[X_]:= (AntisymQ[X]||SymQ[X])&& deg2Q[X]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z_?deg1Q,F__?deg2revParityQ\[RightAngleBracket]:=\[LeftAngleBracket]rev[F],z\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z_?deg1Q,F___?deg2revParityQ,X_/;deg[X]>2&&SymQ[X]\[RightAngleBracket]:=\[LeftAngleBracket]rev[F,X],z\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z_?deg1Q,F1___?deg2revParityQ,X_/;deg[X]>2&&AntisymQ[X]\[RightAngleBracket]:=revSignAntisym[deg[X]-1]\[LeftAngleBracket]rev[F1,X],z\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z1_?deg1Q,F__?deg2revParityQ,z2_?deg1Q\[RightAngleBracket]/;!OrderedAkaQ[{z1,F,z2},Reverse[{z1,F,z2}]]:=\[LeftAngleBracket]z2,rev[F],z1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z1_?deg1Q,F1___?deg2revParityQ,X_/;deg[X]>2&&SymQ[X],F2___?deg2revParityQ,z2_?deg1Q\[RightAngleBracket]/;!OrderedAkaQ[{z1,F1,X,F2,z2},Reverse[{z1,F1,X,F2,z2}]]:=
\[LeftAngleBracket]z2,rev[F1,X,F2],z1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z1_?deg1Q,F1___?deg2revParityQ,X_/;deg[X]>2&&AntisymQ[X],F2___?deg2revParityQ,z2_?deg1Q\[RightAngleBracket]/;!OrderedAkaQ[{z1,F1,X,F2,z2},Reverse[{z1,F1,X,F2,z2}]]:=
revSignAntisym[deg[X]-2]\[LeftAngleBracket]z2,rev[F1,X,F2],z1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]F1_?deg2revParityQ, F2__?deg2revParityQ\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)/;!OrderedAkaQ[{F1,F2},Reverse[{F1,F2}]]:=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]rev[F1, F2]\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)]


(* ::Input::Initialization:: *)
AddRule[0,rev[f_?revEvenQ]:=f]
AddRule[0,rev[f_?revOddQ]:=-f]


(* ::Input::Initialization:: *)
AddRule[rev[X_SeriesData]:=MapAt[Map[rev,#]&,X,3]]


(* ::Input::Initialization:: *)
Clear[Cyclic]


(* ::Input::Initialization:: *)
Cyclic[X_]:=Module[{n,j},
If[!Apply[SameQ,SlotType[X]],Print["CyclicSum: The given argument has mixed slot types, ",SlotType[X],"."];Abort[]];
n=deg[X];
Sum[mv[Join[Range[j,n],Range[1,j-1]]][X],{j,1,deg[X]}]]


(* ::Input::Initialization:: *)
AddRule[mv[n_List]:=mv[Apply[Sequence,n]]]


(* ::Input::Initialization:: *)
PadList[n_List,len_Integer]:= Join[n,Range[Length[n]+1,len]]


(* ::Input::Initialization:: *)
AddRule[mv[n1___Integer][mv[n2___Integer]]:=Module[{len},
len=Max[Length[{n1}],Length[{n2}]];
Apply[mv,Part[PadList[{n2},len],PadList[{n1},len]]]]]


(* ::Input::Initialization:: *)
AddRule[mvInverse[n_List]:=mvInverse[Apply[Sequence,n]]]


(* ::Input::Initialization:: *)
AddRule[mvInverse[n__Integer]:= Module[{arg,j},
arg={n};
Do[arg[[{n}[[j]]]]=j,{j,1,Length[arg]}];
mv[arg]]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mv[n__Integer][X_]/;!X===0&&!PermutationListQ[{n}]:=(
Print["If the argument of mv[ ] evaluates to a sequence or list of integers, then it is required to be a permutation of 1,2,...,n (some n)."];Print["The list of arguments is " ,{n} ,"."];Hold[mv[n]])
]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mv[n__][X_]/;!X===0&&Apply[Or,Map[Greater[#,Length[{n}]]&,{n}]]:=(
Print["The argument sequence of mv[ ] can not contain any integer greater than the length of the sequence."];
Print["The list of arguments is " ,{n} ,"."];
Hold[mv[n]])
]] 


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mv[n__Integer][X_]/;!X===0&&deg[X]<Length[{n}]:=(
Print[mv[n], " operates on tensors that have degree \[GreaterEqual] ",Length[{n}],"."];
Print["The tensor argument ",X," has degree ",deg[X],"."];
Hold[mv[n][X]])
]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mvInverse[n__Integer][X_]/;!X===0&&!PermutationListQ[{n}]:=(
Print["If the argument of mv[ ] evaluates to a sequence or list of integers, then it is required to be a permutation of 1,2,...,n (some n)."];Print["The argument list is " ,{n} ,"."];Hold[mvInverse[n]])
]] 


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mvInverse[n__][X_]/;!X===0&&Apply[Or,Map[Greater[#,Length[{n}]]&,{n}]]:=(
Print["The argument of mvInverse[ ] can not contain any integer greater than the argument length."];
Hold[mvInverse[n]])
]] 


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
mvInverse[n__Integer][X_]/;!X===0&&deg[X]<Length[{n}]:=(
Print[mv[n], " operates on tensors that have degree \[GreaterEqual] ",Length[{n}],"."];
Print["The tensor argument has degree ",deg[X],"."];
Hold[mvInverse[n][X]])
]]


(* ::Input::Initialization:: *)
mvSignature[n___Integer/;PermutationListQ[{n}]]:=Apply[Times,(-1)^(Map[Length,First[PermutationCycles[{n}]]]-1)]


(* ::Input::Initialization:: *)
mvSignature[n_List]:=mvSignature[Apply[Sequence,n]]
mvSignature[n_mv]:=mvSignature[Apply[Sequence,n]]


(* ::Input::Initialization:: *)
mvCyclic[m__?IntegerQ]:=Apply[mv,ReplacePart[Range[Max[m]],MapThread[Rule, {{m},RotateLeft[{m}]}]]]


(* ::Input::Initialization:: *)
mv[n__Integer]/;{n}===Range[Length[{n}]] :=mv[]


(* ::Input::Initialization:: *)
AddRule[mv[][X_]:=X]


(* ::Input::Initialization:: *)
deg[mv[__][X_]]:=deg[X]


(* ::Input::Initialization:: *)
AddRule[mv[n___][] := mv[n]]


(* ::Input::Initialization:: *)
AddRule[rev[mv[n__][X_/;IntegerQ[deg[X]]]]:= mv[Reverse[Range[deg[X]]]][mv[n]][X]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][rev[X_/;IntegerQ[deg[X]]]]:=mv[n][mv[Reverse[Range[deg[X]]]]][X]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X_Plus]:= Map[mv[n],X]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][(a_/;deg[a]===0)X_]:=a mv[n][X]]


(* ::Input::Initialization:: *)
AddRule[mv[__][0]:=0]


(* ::Input::Initialization:: *)
AddRule[mv[n1__][mv[n2__][X_]]:= mv[n1][mv[n2]][X]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X_List]:=Module[{len},
len=Length[X];
Part[X,PadList[{n},len]]]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X_SeriesData]:=MapAt[Map[mv[n][#]&,#]&,X,3]]


(* ::Input::Initialization:: *)
AddRule[mv[n1__][(Y1___/;IntegerQ[deg[Y1]])\[CircleTimes]mv[n2__][X_]\[CircleTimes]Y2___]:= mv[n1][mv[Apply[Sequence,Range[deg[Y1]]],Apply[Sequence,{n2}+deg[Y1] ]]] [Y1\[CircleTimes]X\[CircleTimes]Y2]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X__\[CircleTimes]Y__]/;mvSplitQ[{n},{deg[X],deg[Y]}]:= tpSplit[{n},CircleTimes[X],CircleTimes[Y]]]


(* ::Input::Initialization:: *)
If[$VersionNumber < 8.0,

mvSplitQ[n_,{p_Integer,q_Integer}]:=Module[{ab,s,i,j},
ab = Join[Table[1,{i,p}],Table[0,{j,q}]];
s =Apply[mv,n][ab];
(LengthWhile[s,SameQ[#,1]&]===p)||(LengthWhile[s,SameQ[#,0]&]===q)],

mvSplitQ[n_,{p_Integer,q_Integer}]:=Module[{i},
If[Length[n]>p+q,Return[False]];
If[!PermutationListQ[Apply[List,n]],Print["mvSplitQ: The argument ",Apply[List,n]," should be a permutation list."];Abort[]];
i = Apply[mv,n][Range[p+q]];
PermutationListQ[Take[i,p]]||PermutationListQ[Take[i,-p]]]
]


(* ::Input::Initialization:: *)
Clear[mvSplit]
mvSplit[n_,{p_Integer,q_Integer}]:= Module[{i,P,Q},
i = Apply[mv,n][Range[p+q]];
If[PermutationListQ[Take[i,p]],
P=Apply[mv,Take[i,p]];
Q=Apply[mv,Take[i,-q]-p];
Return[{1,P,Q}]];
If[PermutationListQ[Take[i,-p]],
P=Apply[mv,Take[i,-p]];
Q=Apply[mv,Take[i,q]-p];
Return[{2,P,Q}]];
{0,Null,Null}
]


(* ::Input::Initialization:: *)
Clear[tpSplit]
tpSplit[n_,X_,Y_]:=Module[{c,P,Q},
{c,P,Q}=mvSplit[n,{deg[X],deg[Y]}];
If[c===1, P[X]\[CircleTimes]Q[Y],
If[c===2,Q[Y]\[CircleTimes]P[X],
Apply[mv,n][X\[CircleTimes]Y]]]]


(* ::Input::Initialization:: *)
SetmvArgLengthFixed[]:=If[!ArgLengthOfmvIsFixed,
ArgLengthOfmvIsFixed=True;
Off[Unset::norep];mv[n__Integer]/;Last[{n}]===Length[{n}]=.;On[Unset::norep];
mv[n__Integer][X_]/;deg[X]>Length[{n}]:=Apply[mv,Join[{n},Range[Length[{n}]+1,deg[X]]]][X];]


(* ::Input::Initialization:: *)
SetmvArgLengthVariable[]:=
If[ArgLengthOfmvIsFixed,
ArgLengthOfmvIsFixed=False;
Off[Unset::norep];mv[n__Integer][X_]/;deg[X]>Length[{n}]=.;On[Unset::norep];
mv[n__Integer]/;Last[{n}]===Length[{n}]:=Apply[mv,Most[{n}]];]


(* ::Input::Initialization:: *)
ArgLengthOfmvIsFixed=False;
SetmvArgLengthFixed[]


(* ::Input::Initialization:: *)
deg[]=0;


(* ::Input::Initialization:: *)
deg[mvToLast[_,X_]]:=deg[X]


(* ::Input::Initialization:: *)
mvToLast[_,0]:=0;


(* ::Input::Initialization:: *)
AddRule[mvToLast[n_,X_]/;n===deg[X]:=X]


(* ::Input::Initialization:: *)
AddRule[mvToLast[n_Integer,X_]/;TrueQ[n<deg[X]]:=mv[Append[DeleteCases[Range[deg[X]],n],n]][X]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]mvToLast[n_,X__\[CircleTimes]Y__],v_?deg1Q\[RightAngleBracket]/;n===deg[X]:=\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]mvToLast[n_,X_]/;n===deg[X]-1,v_?deg1Q\[RightAngleBracket],u_?deg1Q\[RightAngleBracket]:=\[LeftAngleBracket]\[LeftAngleBracket]X,u\[RightAngleBracket],v\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[sym[n___][X_Plus]:= Map[sym[n],X]]
AddRule[sym[n___][(a_?deg0Q)X_]:=a sym[n][X]]


(* ::Input::Initialization:: *)
AddRule[alt[n___][X_Plus]:= Map[alt[n],X]]
AddRule[alt[n___][(a_?deg0Q)X_]:=a alt[n][X]]


(* ::Input::Initialization:: *)
AddRule[sym[][0]:=0]
AddRule[alt[][0]:=0]


(* ::Input::Initialization:: *)
symMessage[n_]:=Print["The argument in sym[" , n, "] must be a sequence or list of distinct elements."]


(* ::Input::Initialization:: *)
sym[n_List]:= sym[Apply[Sequence,n]]


(* ::Input::Initialization:: *)
sym[][X_/;IntegerQ[deg[X]]&&deg[X]>0]:=sym[Range[deg[X]]][X]


(* ::Input::Initialization:: *)
sym[][X_?deg0Q]:=X


(* ::Input::Initialization:: *)
sym[n___][sym[]]:=sym[]


(* ::Input::Initialization:: *)
sym[][sym[n___]]:=sym[]


(* ::Input::Initialization:: *)
sym[n_Integer]:=mv[]


(* ::Input::Initialization:: *)
deg[sym[___][X_]]:=deg[X]


(* ::Input::Initialization:: *)
sym[n__Integer][X___]:= Module[{u,m,c,s,i,j},
If[Length[{X}]>1,Print["If an argument appears within the 2nd pair of square brackets of sym[][], then it should be a single tensor. See: ? sym"]];
s = Length[{n}];
If[!Length[Union[{n}]]===s,symMessage[{n}]; Abort[]] ;
c[0]=mv[];
c[1]=mvCyclic[n];
Do[c[i]=c[1][c[i-1]],{i,2,s-1}];
m = Rest[{n}];
Expand[Sum[sym[m][c[j][X]],{j,0,s-1}](s-1)!]/s!]


(* ::Input::Initialization:: *)
mvCyclic[m__?IntegerQ]:=Apply[mv,ReplacePart[Range[Max[m]],MapThread[Rule, {{m},RotateLeft[{m}]}]]]


(* ::Input::Initialization:: *)
If[ArgumentChecking,
sym[n__][X_]/;IntegerQ[deg[X]]&&(deg[X]<Length[{n}]|| deg[X]<Max[Cases[{n},_Integer]]):=(Print[sym[n], " operates on tensors that have degree \[GreaterEqual] ",Max[Max[Cases[{n},_Integer]],Length[{n}]],". 
The given tensor has degree ",deg[X],"."];Abort[])]


(* ::Input::Initialization:: *)
alt[___][X_?AntisymQ]:=X


(* ::Input::Initialization:: *)
altMessage[n_]:=Print["The argument in alt[" , n, "] must be a sequence or list of distinct elements."]


(* ::Input::Initialization:: *)
alt[n_List]:= alt[Apply[Sequence,n]]


(* ::Input::Initialization:: *)
alt[][X_/;IntegerQ[deg[X]]&&deg[X]>0]:=alt[Range[deg[X]]][X]


(* ::Input::Initialization:: *)
alt[][X_?deg0Q]:=X


(* ::Input::Initialization:: *)
alt[n___][alt[]]:=alt[]


(* ::Input::Initialization:: *)
alt[][alt[n___]]:=alt[]


(* ::Input::Initialization:: *)
alt[n_Integer]:=mv[]


(* ::Input::Initialization:: *)
deg[alt[__][X_]]:=deg[X]


(* ::Input::Initialization:: *)
alt[n__Integer][X___]:= Module[{u,m,c,s,i,j,k},
If[Length[{X}]>1,Print["If an argument appears within the 2nd square brackets of alt[][] then it should be a single tensor. See: ? alt"]];
s = Length[{n}];
If[!Length[Union[{n}]]===s,altMessage[{n}]; Abort[]] ;
c[0]=mv[];
c[1]=mvCyclic[n];
Do[c[i]=c[1][c[i-1]],{i,2,s-1}];
m = Rest[{n}];
If[EvenQ[s],
Expand[Sum[(-1)^j alt[m][c[j][X]],{j,0,s-1}](s-1)!]/s!,
Expand[Sum[              alt[m][c[k][X]],{k,0,s-1}](s-1)!]/s!]]


(* ::Input::Initialization:: *)
If[ArgumentChecking,
alt[n__][X_]/;IntegerQ[deg[X]]&&(deg[X]<Length[{n}]|| deg[X]<Max[Cases[{n},_Integer]]):=(Print[alt[n], " operates on tensors that have degree \[GreaterEqual] ",Max[Max[Cases[{n},_Integer]],Length[{n}]],". 
The given tensor has degree ",deg[X],"."];Abort[])]


(* ::Input::Initialization:: *)
Permuted[X_List]:=Permutations[Range[Length[X]]]/.MapThread[Rule,{Range[Length[X]],X}]


(* ::Input::Initialization:: *)
Clear[AlternatingSum]


(* ::Input::Initialization:: *)
AlternatingSum[n__][X_]:=AlternatingSum[X,{n}]


(* ::Input::Initialization:: *)
AlternatingSum[X_,n_List]:=Module[{perms,vals,sigs},
perms=Permuted[n];
vals=X/.Map[MapThread[Rule,{n,#}]&,perms];
sigs= Signature[n]Map[Signature,perms];
sigs.vals
]


(* ::Input::Initialization:: *)
Clear[SymmetricSum]


(* ::Input::Initialization:: *)
SymmetricSum[n__][X_]:=SymmetricSum[X,{n}]


(* ::Input::Initialization:: *)
SymmetricSum[X_,n_List]:=Module[{perms,vals},
perms=Permuted[n];
vals=X/.Map[MapThread[Rule,{n,#}]&,perms];
Apply[Plus,vals]
]


(* ::Input::Initialization:: *)
Clear[CyclicSum]
CyclicSum[n__][X_]:=CyclicSum[X,{n}]


(* ::Input::Initialization:: *)
CyclicSum[X_,n_List]:=Module[{perms,vals},
perms=Permute[n,CyclicGroup[Length[n]]];
vals=X/.Map[MapThread[Rule,{n,#}]&,perms];
Apply[Plus,vals]Length[n]/Length[perms]
]


(* ::Input::Initialization:: *)
SymmetricQ[X_]:= Module[{}, Print["do zero-check on diff for swapping all slot pairs"]]


(* ::Input::Initialization:: *)
AntisymmetricQ[X_]:= Module[{}, Print["do zero-check on sum for swapping all slot pairs"]]


(* ::Input::Initialization:: *)
SymmetricQ[X_,s_List]:= Module[{}, Print["do zero-check on diff for swapping all slot pairs listed in s"]]


(* ::Input::Initialization:: *)
AntisymmetricQ[X_,s_List]:= Module[{}, Print["do zero-check on sum for swapping all slot pairs listed in s"]]


(* ::Input::Initialization:: *)
SymQ[X_]:=False
AntisymQ[X_]:=False


(* ::Input::Initialization:: *)
SymQ[CircleTimes[X_ ,X_ ..]/;FieldLikeQ[X]&&deg1Q[X]]:=True


(* ::Input::Initialization:: *)
AntisymQ[Derivative[__][X_?AntisymQ]]:=True


(* ::Input::Initialization:: *)
SymQ[Derivative[__][X_?SymQ]]:=True


(* ::Input::Initialization:: *)
AntisymQ[\[GothicCapitalD][X_?AntisymQ]]:=True
AntisymQ[\[GothicCapitalD][X_?AntisymQ,_]]:=True


(* ::Input::Initialization:: *)
SymQ[\[GothicCapitalD][X_?SymQ]]:=True
SymQ[\[GothicCapitalD][X_?SymQ,_]]:=True


(* ::Input::Initialization:: *)
AntisymQ[pD[X_?AntisymQ,__]]:=True


(* ::Input::Initialization:: *)
SymQ[pD[X_?SymQ,__]]:=True


(* ::Input::Initialization:: *)
AntisymQ[\[LeftAngleBracket]\[Del](X_?AntisymQ),v_?deg1Q\[RightAngleBracket]]:=True


(* ::Input::Initialization:: *)
SymQ[\[LeftAngleBracket]\[Del](X_?SymQ),v_?deg1Q\[RightAngleBracket]]:=True


(* ::Input::Initialization:: *)
HasSymQ[X_]:=AntisymQ[X]||SymQ[X]
HasSymQ[X__]:=Apply[And,Map[HasSymQ,{X}]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X_?SymQ]:=X]
AddRule[mv[n__][(X_?SymQ)[s__]]:=X[s]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][X_?AntisymQ]:=X  mvSignature[n]]
AddRule[mv[n__][(X_?AntisymQ)[s__]]:=X[s]  mvSignature[n]]


(* ::Input::Initialization:: *)
AddRule[AntisymQ[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X_ /; FieldLikeQ[X] && deg2Q[X], \[CurlyEpsilon]4\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)]:=True]


(* ::Input::Initialization:: *)
AddRule[SymQ[\[LeftAngleBracket]g_?SymQ,X_?SymQ,g_?SymQ\[RightAngleBracket]/;deg[g]===2&&deg[X]===2]:=True]


(* ::Input::Initialization:: *)
AddRule[AntisymQ[\[LeftAngleBracket]g_?SymQ,X_?AntisymQ,g_?SymQ\[RightAngleBracket]/;deg[g]===2&&deg[X]===2]:=True]


(* ::Input::Initialization:: *)
AssumeSymmetric[X_List]:=(Map[AssumeSymmetric[#]&,X]//Column)
ForgetAssumeSymmetric[X_List]:=(Map[ForgetAssumeSymmetric[#]&,X]//Column)


(* ::Input::Initialization:: *)
AssumeSymmetric[X_/;!Head[X]===List]:=Module[{msg},
If[!Length[FieldType[X][[2]]]===1,
msg=Row[{"AssumeSymmetric: ",X," has slots of mixed type, FieldType[",X,"]\[MediumSpace]=\[ThickSpace]",FieldType[X],", so can not be declared fully symmetric."}];
Print[msg];Abort[]];
If[AntisymQ[X],
Print["Tensor ",X," is already declared antisymmetric."];Print["AssumeSymmetric: To re-declare ",X," as symmetric, first use either ForgetAssumeAntisymmetric[",X,"] or ClearField[",X,"]." ];
Abort[]];
If[!IntegerQ[deg[X]],
Print["AssumeSymmetric: deg[",X,"] does not evaluate to an integer. See  ? NewField  for declaring the degree of a tensor field."];Abort[]];
If[deg[X]>1,SymQ[X]=True];
If[deg[X]===0|| deg[X]===1,msg="By definition, SymQ[X] = False  and  AntisymQ[X] = False  for any X of degree 0 or 1."];
If[deg[X]===2,msg=Row[{"The degree \[VeryThinSpace]",deg[X]," tensor field ",X," is now assumed to be symmetric."}]];
If[deg[X]>2,msg=Row[{"The degree \[VeryThinSpace]",deg[X]," tensor field ",X," is now assumed to be fully symmetric."}]];
msg
]


(* ::Input::Initialization:: *)
ForgetAssumeSymmetric[X_/;!Head[X]===List]:=Module[{u,msg},
If[!SymQ[X],
msg=Row[{"No change made: Tensor field ",X," was not symmetric."}];
Return[msg]];
SymQ[X]=.;
Row[{"Tensor field ",X," is no longer assumed to be symmetric."}]
]


(* ::Input::Initialization:: *)
AddRule[mv[n__][Y1___\[CircleTimes](X_?SymQ)\[CircleTimes]Y2___]/;IntegerQ[deg[X]]&&!PartiallySortedQ[{n},deg[Y1]+Range[deg[X]]]:=mv[PartiallySort[{n},deg[Y1]+Range[deg[X]]]][Y1\[CircleTimes]X\[CircleTimes]Y2]]


(* ::Input::Initialization:: *)
AddRule[mv[n__][Y1___\[CircleTimes](X_?SymQ)[s__]\[CircleTimes]Y2___]/;IntegerQ[deg[X[s]]]&&!PartiallySortedQ[{n},deg[Y1]+Range[deg[X[s]]]]:=mv[PartiallySort[{n},deg[Y1]+Range[deg[X[s]]]]][Y1\[CircleTimes]X[s]\[CircleTimes]Y2]]


(* ::Input::Initialization:: *)
Clear[PartiallySort]
PartiallySort[x_List,y_List]:= Module[{s,imax,z,i},
s = Sort[y];
imax=Length[x];
z=x;
Do[If[MemberQ[y,x[[i]]],
z[[i]]=First[s];s=Rest[s]];If[s==={},Break[]],
{i,imax} ];
z]


(* ::Input::Initialization:: *)
Clear[PartiallySortedQ]
PartiallySortedQ[x_List,y_List]:= Module[{s,i,imax},
s = Sort[y];
imax=Length[x];
i =1;
While[!s==={}&& i<=imax,
If[MemberQ[y,x[[i]]],
If[!x[[i]]===First[s],Return[False],s=Rest[s]]];
i++
];
True]


(* ::Input::Initialization:: *)
Clear[AssumeAntisymmetric]
Clear[ForgetAssumeAntisymmetric]


(* ::Input::Initialization:: *)
AssumeAntisymmetric[X_List]:=(Map[AssumeAntisymmetric[#]&,X]//Column)
ForgetAssumeAntisymmetric[X_List]:=(Map[ForgetAssumeAntisymmetric[#]&,X]//Column)


(* ::Input::Initialization:: *)
AssumeAntisymmetric[X_/;!Head[X]===List]:=Module[{msg},
If[SymQ[X],
Print["Tensor ",X," is already declared symmetric."];Print["To re-declare ",X," as antisymmetric, first use either ForgetAssumeSymmetric[",X,"] or ClearField[",X,"]." ];
Abort[]];
If[!IntegerQ[deg[X]],
Print["deg[",X,"] does not evaluate to an integer. See  ? NewField  for declaring the degree of a tensor field."];Abort[]];
If[deg[X]>1,AntisymQ[X]=True];
If[deg[X]===0|| deg[X]===1,msg="By definition, SymQ[X] = False  and  AntisymQ[X] = False  for any X of degree 0 or 1."];
If[deg[X]===2,msg=Row[{"The degree \[VeryThinSpace]",deg[X]," tensor field ",X," is now assumed to be antisymmetric."}]];
If[deg[X]>2,msg=Row[{"The degree \[VeryThinSpace]",deg[X]," tensor field ",X," is now assumed to be fully antisymmetric."}]];
msg
]


(* ::Input::Initialization:: *)
ForgetAssumeAntisymmetric[X_/;!Head[X]===List]:=Module[{u,msg},
If[!AntisymQ[X],
msg="Tensor field "<>ToString[X,StandardForm]<>" was not antisymmetric. No changes made.";
msg=Row[{"No change made: Tensor field ",X," was not antisymmetric."}];
Return[msg]];
AntisymQ[X]=.;
Row[{"Tensor field ",X," is no longer assumed to be antisymmetric."}]
]


(* ::Input::Initialization:: *)
AddRule[ mv[n__][Y1___\[CircleTimes](X_?AntisymQ)\[CircleTimes]Y2___]/;IntegerQ[deg[X]]&&!PartiallySortedQ[{n},deg[Y1]+Range[deg[X]]]:=mvSignature[n]mvSignature[PartiallySort[{n},deg[Y1]+Range[deg[X]]]]mv[PartiallySort[{n},deg[Y1]+Range[deg[X]]]][Y1\[CircleTimes]X\[CircleTimes]Y2] ]


(* ::Input::Initialization:: *)
AddRule[ mv[n__][Y1___\[CircleTimes](X_?AntisymQ)[s__]\[CircleTimes]Y2___]/;IntegerQ[deg[X[s]]]&&!PartiallySortedQ[{n},deg[Y1]+Range[deg[X[s]]]]:=mvSignature[n]mvSignature[PartiallySort[{n},deg[Y1]+Range[deg[X[s]]]]]mv[PartiallySort[{n},deg[Y1]+Range[deg[X[s]]]]][Y1\[CircleTimes]X[s]\[CircleTimes]Y2] ]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X1___, X_?SymQ, Y_?AntisymQ\[RightAngleBracket]\[RightAngleBracket]\), \({a_, b_}\)]\)/;degBracket[X1]<=a<degBracket[X1,X]<=b:=0]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X1___, X_?SymQ, Y_?AntisymQ, Y1__\[RightAngleBracket]\[RightAngleBracket]\), \({a_, b_}\)]\)/;degBracket[X1]<=a<degBracket[X1,X]<=b<degBracket[X1,X,Y]:=0]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X1___, X_?AntisymQ, Y_?SymQ\[RightAngleBracket]\[RightAngleBracket]\), \({a_, b_}\)]\)/;degBracket[X1]<=a<degBracket[X1,X]<=b:=0]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X1___, X_?AntisymQ, Y_?SymQ, Y1__\[RightAngleBracket]\[RightAngleBracket]\), \({a_, b_}\)]\)/;degBracket[X1]<=a<degBracket[X1,X]<=b<degBracket[X1,X,Y]:=0]


(* ::Input::Initialization:: *)
Clear[mvCrossingNumber]
mvCrossingNumber[n_List]:=mvCrossingNumber[n]=Module[{s,m,i,j},
s=0;
m=Length[n];
Do[If[n[[i]]>n[[j]],s=s+1],
{i,1,m-1},
{j,i+1,m}];
s]


(* ::Input::Initialization:: *)
CrossingOrderedQ[n1_,n2_]:= mvCrossingNumber[n1]<=mvCrossingNumber[n2]


(* ::Input::Initialization:: *)
mvOrderedQ[n1_List,n2_List]:= If[mvCrossingNumber[n1]===mvCrossingNumber[n2],mvListOrderedQ[n1,n2],
mvCrossingNumber[n1]<mvCrossingNumber[n2]]


(* ::Input::Initialization:: *)
mvListOrderedQ[n1_List,n2_List]:=If[n1==={}||n2==={}||(First[n1]<First[n2]),True,
If[First[n1]===First[n2], mvListOrderedQ[Rest[n1],Rest[n2]],False]]


(* ::Input::Initialization:: *)
AddRule[mv[n__Integer][Y1___\[CircleTimes](X1_/;FreeQ[X1,CircleTimes])\[CircleTimes](X2_/;FreeQ[X2,CircleTimes])\[CircleTimes]Y3___]/;IntegerQ[deg[X1]]&&IntegerQ[deg[X2]]&&IntegerQ[deg[Y1]]&&IntegerQ[deg[Y3]]&&!mvOrderedQ[{n},Apply[List,mvSwapped[{n},deg[Y1],deg[X1],deg[X2],deg[Y3]]]]:=  mvSwapped[{n},deg[Y1],deg[X1],deg[X2],deg[Y3]][Y1\[CircleTimes]X2\[CircleTimes]X1\[CircleTimes]Y3]]


(* ::Input::Initialization:: *)
mvSwapped[n_List,y1_Integer,x1_Integer,x2_Integer,y2_Integer]:=
mv[n][mvInverse[Join[
Range[y1],
Range[x2]+y1+x1,
Range[x1]+y1,
Range[y2]+y1+x1+x2]]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1_\[CircleTimes]X2_\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1]&&b===a+1:=\[LeftAngleBracket]X1,X2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
ArgumentCheck[
AddRule[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]/;Max[ab]>deg[X]|| Min[ab]<1:=(
Print["A contraction subscript is out of range." ];
Print["For the given argument, slot values should be in the range 1 to ",deg[X],"."];
Print["The given subscript slot pairs are: ",ab];
Hold[Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab]])]]


(* ::Input::Initialization:: *)
ArgumentCheck[
AddRule[Subscript[\[LeftAngleBracket]X__\[RightAngleBracket], ab__List]/;Length[{X}]>1:=(
Print["The general contraction bracket \[LeftAngleBracket]\[VeryThinSpace]_\[VeryThinSpace]\!\(\*SubscriptBox[\(\[RightAngleBracket]\), \(__\)]\) only takes a single argument:" ];
Hold[Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab]])]]


(* ::Input::Initialization:: *)
deg[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]]:=deg[X]-2Length[{ab}]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]/;!OrderedPairsQ[{ab}]:=Subscript[\[LeftAngleBracket]X\[RightAngleBracket], OrderedPairs[{ab}]]]


(* ::Input::Initialization:: *)
OrderedPairs[ab_List]:= Apply[Sequence,Sort[Map[Sort,ab]]]


(* ::Input::Initialization:: *)
OrderedPairsQ[ab_List]:= {OrderedPairs[ab]}===ab


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__Integer]:=Subscript[\[LeftAngleBracket]X\[RightAngleBracket], Apply[Sequence,Partition[{ab},2]]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab1__List]\[RightAngleBracket], ab2__List]:=Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab1ab2[{ab1},{ab2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1__\[CircleTimes]Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab1__List]\[RightAngleBracket], ab2__List]/;IntegerQ[deg[Y1]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]X\[RightAngleBracket], ab1ab2[{ab1}+deg[Y1],{ab2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab1__List]\[CircleTimes]Y2__\[RightAngleBracket], ab2__List]:=Subscript[\[LeftAngleBracket]X\[CircleTimes]Y2\[RightAngleBracket], ab1ab2[{ab1},{ab2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1__\[CircleTimes]Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab1__List]\[CircleTimes]Y2__\[RightAngleBracket], ab2__List]/;IntegerQ[deg[Y1]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]X\[CircleTimes]Y2\[RightAngleBracket], ab1ab2[{ab1}+deg[Y1],{ab2}]]]


(* ::Input::Initialization:: *)
ab1ab2[ab1_List,ab2_List]:=Module[{f1,f2,n,slots},
f1=Flatten[ab1];
f2=Flatten[ab2];
n = Max[f1,Max[f2]+Length[f1]];
slots = Select[Range[n],!MemberQ[f1,#]&];
OrderedPairs[Partition[Join[f1,slots[[f2]]],2]]
]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]v_CircleTimes\[RightAngleBracket], ab__List]/;Simplify[Min[Flatten[{ab}]]>deg[First[v]]]:=First[v]\[CircleTimes]Subscript[\[LeftAngleBracket]Rest[v]\[RightAngleBracket], Apply[Sequence,{ab}-deg[First[v]]]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]v_CircleTimes\[RightAngleBracket], ab__List]/;Simplify[Max[Flatten[{ab}]]<=deg[Most[v]]]:=Subscript[\[LeftAngleBracket]Most[v]\[RightAngleBracket], ab]\[CircleTimes]Last[v]]


(* ::Input::Initialization:: *)
CommaToProduct = Subscript[\[LeftAngleBracket]X__\[RightAngleBracket], ab__List]:>Subscript[\[LeftAngleBracket](\[CircleTimes]X)\[RightAngleBracket], abComma[{ab},{X}]]


(* ::Input::Initialization:: *)
abComma[ab_List,X_List]:=OrderedPairs[Join[ab,Map[{#,#+1}&,Most[PartialSum[deg[X]]]]]]


(* ::Input::Initialization:: *)
PartialSum[{}]={};
PartialSum[x_List]:= Prepend[First[x]+PartialSum[Rest[x]],First[x]]


(* ::Input::Initialization:: *)
AddRule[0,
\!\(\*SubscriptBox[\(\[LeftAngleBracket]x1_?deg1Q\[CircleTimes]x2_?deg1Q\[RightAngleBracket]\), \({1, 2}\)]\):=\[LeftAngleBracket]x1,x2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
abDrop[ab_List,{s1_,s2_}]/;Simplify[s1<s2]:=Module[{f},
f:=If[Simplify[#>s2],#-2,If[Simplify[#>s1],#-1,#]]&;
Apply[Sequence,Map[f,DeleteCases[ab,{s1,s2}],{2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]v_?deg1Q\[CircleTimes]Y2___\[CircleTimes]X_\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&MemberQ[{ab},{deg[Y1]+1,deg[Y1]+deg[Y2]+2}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]Y2\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y3\[RightAngleBracket], abDrop[{ab},{deg[Y1]+1,  deg[Y1]+deg[Y2]+2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]v_?deg1Q\[CircleTimes]Y2___\[CircleTimes]X_\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&MemberQ[{ab},{deg[Y1]+1,deg[Y1]+deg[Y2]+deg[X]+1}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]Y2\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y3\[RightAngleBracket], abDrop[{ab},{deg[Y1]+1,  deg[Y1]+deg[Y2]+deg[X]+1}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[CircleTimes]v_?deg1Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&MemberQ[{ab},{deg[Y1]+1,deg[Y1]+deg[X]+deg[Y2]+1}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abDrop[{ab},{deg[Y1]+1,  deg[Y1]+deg[Y2]+deg[X]+1}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[CircleTimes]v_?deg1Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&MemberQ[{ab},{deg[Y1]+deg[X],deg[Y1]+deg[X]+deg[Y2]+1}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abDrop[{ab},{deg[Y1]+deg[X],  deg[Y1]+deg[Y2]+deg[X]+1}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]v_?deg1Q\[CircleTimes]Y2___\[CircleTimes]X_\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+1,deg[Y1]+deg[Y2]+2}:=Y1\[CircleTimes]Y2\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]v_?deg1Q\[CircleTimes]Y2___\[CircleTimes]X_\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+1,deg[Y1]+deg[Y2]+deg[X]+1}:=Y1\[CircleTimes]Y2\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[CircleTimes]v_?deg1Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+1,deg[Y1]+deg[X]+deg[Y2]+1}:=Y1\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[CircleTimes]v_?deg1Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+deg[X],deg[Y1]+deg[X]+deg[Y2]+1}:=Y1\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
abDrop[ab_List,s_]:=Module[{f},
f:=If[Simplify[#>s],#-1,#]&;
Apply[Sequence,Map[f,ab,{2}]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[RightAngleBracket], ab__List],v_?deg1Q\[RightAngleBracket]/;IntegerQ[deg[X]+deg[Y2]]&&
!MemberQ[{ab},deg[Y1]+1,{2}]&& SubsetQ[Flatten[{ab}],deg[Y1]+Range[2,deg[X]+deg[Y2]]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y2\[RightAngleBracket], abDrop[{ab},deg[Y1]+1]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v_?deg1Q,Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[RightAngleBracket], ab__List]\[RightAngleBracket]/;IntegerQ[deg[Y1]]&&
!MemberQ[{ab},deg[Y1]+1,{2}]&& SubsetQ[Flatten[{ab}],Range[1,deg[Y1]]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]v,X\[RightAngleBracket]\[CircleTimes]Y2\[RightAngleBracket], abDrop[{ab},deg[Y1]+1]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[RightAngleBracket], ab__List],v_?deg1Q\[RightAngleBracket]/;IntegerQ[deg[Y2]]&&
!MemberQ[{ab},deg[Y1]+deg[X],{2}]&& SubsetQ[Flatten[{ab}],deg[Y1]+deg[X]+Range[1,deg[Y2]]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y2\[RightAngleBracket], abDrop[{ab},deg[Y1]+deg[X]]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v_?deg1Q,Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X_\[CircleTimes]Y2___\[RightAngleBracket], ab__List]\[RightAngleBracket]/;IntegerQ[deg[Y1]+deg[X]]&&
!MemberQ[{ab},deg[Y1]+deg[X],{2}]&& SubsetQ[Flatten[{ab}],Range[1,deg[Y1]+deg[X]-1]]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]X,v\[RightAngleBracket]\[CircleTimes]Y2\[RightAngleBracket], abDrop[{ab},deg[Y1]+deg[X]]]]


(* ::Input::Initialization:: *)
abMoveQ[ab_List,{degY1_Integer,degY2_Integer},{x1_,x2_}]:=MemberQ[ab,{x1+degY1,x2+degY1+degY2+2}]&&SubsetQ[Flatten[ab],Range[degY1+3,degY1+degY2+2]]


(* ::Input::Initialization:: *)
abMove[ab_List,{degY1_,degY2_},{x1_,x2_}]:=Module[{f,s1,s2},
s1=degY1+x1;
s2=degY1+degY2+2 + x2;
f:=If[#>degY1+degY2+4,#-2,If[#>degY1+degY2+2,degY1+2,If[#>degY1+2,#,If[#>degY1,degY1+1,#]]]]&;
Apply[Sequence,Map[f,DeleteCases[ab,{s1,s2}],{2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]Y2___\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&abMoveQ[{ab},{deg[Y1],deg[Y2]},{1,1}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]rev[X1],X2\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abMove[{ab},{deg[Y1],deg[Y2]},{1,1}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]Y2___\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&abMoveQ[{ab},{deg[Y1],deg[Y2]},{1,2}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]rev[X1],rev[X2]\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abMove[{ab},{deg[Y1],deg[Y2]},{1,2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]Y2___\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&abMoveQ[{ab},{deg[Y1],deg[Y2]},{2,1}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]X1,X2\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abMove[{ab},{deg[Y1],deg[Y2]},{2,1}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]Y2___\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab__List]/;Length[{ab}]>1&&abMoveQ[{ab},{deg[Y1],deg[Y2]},{2,2}]:=Subscript[\[LeftAngleBracket]Y1\[CircleTimes]\[LeftAngleBracket]X1,rev[X2]\[RightAngleBracket]\[CircleTimes]Y2\[CircleTimes]Y3\[RightAngleBracket], abMove[{ab},{deg[Y1],deg[Y2]},{2,2}]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+1,deg[Y1]+3}:=Y1\[CircleTimes]\[LeftAngleBracket]rev[X1],X2\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+1,deg[Y1]+4}:=Y1\[CircleTimes]\[LeftAngleBracket]rev[X1],rev[X2]\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+2,deg[Y1]+3}:=Y1\[CircleTimes]\[LeftAngleBracket]X1,X2\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1___\[CircleTimes]X1_?deg2Q\[CircleTimes]X2_?deg2Q\[CircleTimes]Y3___\[RightAngleBracket], ab_List]/;ab==={deg[Y1]+2,deg[Y1]+4}:=Y1\[CircleTimes]\[LeftAngleBracket]X1,rev[X2]\[RightAngleBracket]\[CircleTimes]Y3]


(* ::Input::Initialization:: *)
FactorDegrees[X_CircleTimes]:=deg[Apply[List,X]]


(* ::Input::Initialization:: *)
PartialSum[{}]={};
PartialSum[x_List]:= Prepend[First[x]+PartialSum[Rest[x]],First[x]]


(* ::Input::Initialization:: *)
FactorSlotRange[fdeg_]:= Module[{r1,r2},
r2=PartialSum[fdeg];
r1=1+Prepend[Most[PartialSum[fdeg]],0];
Transpose[{r1,r2}]]


(* ::Input::Initialization:: *)
PositionOfSlotOwner[{degs__Integer}]:= Flatten[MapThread[Table[#1,{#2}]&,{Range[Length[{degs}]],{degs}}]]


(* ::Input::Initialization:: *)
FactorPairs[{degs__Integer},ab:{{_Integer,_Integer}..}]:=Module[{p},
p=PositionOfSlotOwner[{degs}];
Map[p[[#]]&,ab,{2}]]


(* ::Input::Initialization:: *)
ConnectedFactors[y1___List,x1_List,y2___List,x2_List,y3___List]/;IntersectingQ[x1,x2]:=ConnectedFactors[y1,y2,y3,Union[x1,x2]]


(* ::Input::Initialization:: *)
ConnectedFactors[y1___List,x1_List,y2___List]/;!Union[x1]===x1:=ConnectedFactors[y1,Union[x1],y2]


(* ::Input::Initialization:: *)
ConnectedFactors[y1___List,x1_List,x2_List,y2___List]/;First[x2]<First[x1]:=ConnectedFactors[y1,x2,x1,y2]


(* ::Input::Initialization:: *)
CountContractions[fpair_List,fgrp_List]:=Map[Length,DeleteCases[Outer[IntersectingQ,fgrp,fpair,1],False,2]]


(* ::Input::Initialization:: *)
ConnectedContractions[X_CircleTimes,ab_List]:=Module[{fpair,fdeg,fgrp,TorF},
fdeg=FactorDegrees[X];
fpair=FactorPairs[fdeg,ab];
fgrp=Apply[List,Apply[ConnectedFactors,fpair]];
TorF=Outer[IntersectingQ,fgrp,fpair,1];
Map[Pick[ab,#]&,TorF]
]


(* ::Input::Initialization:: *)
FactorGroupDegree[degX_List, fgrp_List]:= Map[Total,Map[degX[[#]]&,fgrp,{2}]]


(* ::Input::Initialization:: *)
FactorGroupFreeDegree[degX_List,fpair_List]:=Module[{fgrp},
fgrp=Apply[List,Apply[ConnectedFactors,fpair]];
FactorGroupDegree [degX,fgrp ]- 2CountContractions[fpair,fgrp]]


(* ::Input::Initialization:: *)
ScalarContractionQ[X_CircleTimes,ab_List]:=Module[{fdeg,fpair,free},
fdeg=FactorDegrees[X];
fpair = FactorPairs[fdeg,ab];
free=FactorGroupFreeDegree[fdeg,fpair];
Apply[Or,Map[(#===0)&,free]]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]X_CircleTimes\[RightAngleBracket], ab__List]/;deg[X]>2Length[{ab}]&&ScalarContractionQ[X,{ab}]:=SplitContraction[X,{ab}]]


(* ::Input::Initialization:: *)
abAfterDroppingSlots[ab_List,slots_List]:=Module[{r,f},
If[ab==={},Return[{}]];
r=Complement[Range[Max[ab]],slots];
f=First[First[Position[r,#]]]&;
Map[f,ab,{Depth[ab]-1}]]


(* ::Input::Initialization:: *)
abAfterDroppingSlots[ab_List]:=Module[{r,f},
r=Sort[Flatten[ab]];
f=First[First[Position[r,#]]]&;
Map[f,ab,{Depth[ab]-1}]]


(* ::Input::Initialization:: *)
SplitContraction[X_CircleTimes,ab_List]:=
Module[{fpair,fdeg,fgrp,fgrp0,TorF,abgrps,abgrps0,free,free0,X0,scalar,ftensor,Xtensor,abgrps1,ab0New,ab1New},
fdeg=FactorDegrees[X];
fpair=FactorPairs[fdeg,ab];
fgrp=Apply[List,Apply[ConnectedFactors,fpair]];
TorF=Outer[IntersectingQ,fgrp,fpair,1];
abgrps =Map[Pick[ab,#]&,TorF];
free = FactorGroupDegree[fdeg,fgrp]-2CountContractions[fpair,fgrp];
free0 = Map[(#===0)&,free];
abgrps0= Pick[abgrps,free0];
abgrps1= Pick[abgrps,Map[Not,free0]];
ab0New=abAfterDroppingSlots[abgrps0];ab1New=abAfterDroppingSlots[Flatten[abgrps1,1],Flatten[abgrps0]];
fgrp0=Pick[fgrp,free0];
X0=Map[X[[#]]&,fgrp0];
scalar=Apply[Times,MapThread[Subscript[\[LeftAngleBracket]#1\[RightAngleBracket], Apply[Sequence,#2]]&,{X0,ab0New}]];
ftensor=Complement[Range[Length[X]],Apply[Sequence,fgrp0]];
Xtensor= X[[ ftensor]];
If[ab1New==={},
scalar Xtensor,
scalar Subscript[\[LeftAngleBracket]Xtensor\[RightAngleBracket], Apply[Sequence,ab1New]]]]


(* ::Input::Initialization:: *)
deg[\[LeftAngleBracket]X__\[RightAngleBracket]]:=deg[X]-2(Length[{X}]-1)


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]u___,0,v___\[RightAngleBracket]/;!MemberQ[Map[Head,{u,v}],List]:=0]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]u___,0.,v___\[RightAngleBracket]/;!MemberQ[Map[Head,{u,v}],List]:=0]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]Y1___,X_Plus,Y2___\[RightAngleBracket]:=Map[\[LeftAngleBracket]Y1,#,Y2\[RightAngleBracket]&,X]]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]Y1___,(a_?deg0Q) X_,Y2___\[RightAngleBracket]:=a (\[LeftAngleBracket]Y1,X,Y2\[RightAngleBracket])]


(* ::Input::Initialization:: *)
AddRule[0,Subscript[0, ab__]:=0]


(* ::Input::Initialization:: *)
AddRule[0,Subscript[X_Plus, ab__]:=Map[Subscript[#,ab]&,X]]


(* ::Input::Initialization:: *)
AddRule[0,Subscript[(c_?deg0Q X_), ab__]:=c Subscript[X, ab]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y1__,\[LeftAngleBracket]X1_/;deg[X1]>1,X2__\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]Y1,X1,X2\[RightAngleBracket]]
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]X1__,X2_/;deg[X2]>1\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]X1,X2,Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y1__,\[LeftAngleBracket]X1_/;deg[X1]>1,X2___,X3_/;deg[X3]>1\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]Y1,X1,X2,X3,Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y1__,\[LeftAngleBracket]X1_/;deg[X1]>1,X2___,X3_?deg1Q\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]\[LeftAngleBracket]Y1,X1,X2,X3\[RightAngleBracket],Y2\[RightAngleBracket]]
AddRule[\[LeftAngleBracket]Y1__,\[LeftAngleBracket]X1_?deg1Q,X2___,X3_/;deg[X3]>1\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]Y1,\[LeftAngleBracket]X1,X2,X3,Y2\[RightAngleBracket]\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2revParityQ,z_?deg1Q\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]z,rev[Y1],Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]X_/;deg[X]>2&&SymQ[X],Y1___?deg2revParityQ,z_?deg1Q\[RightAngleBracket],Y2__\[RightAngleBracket]:=\[LeftAngleBracket]z,rev[Y1],X,Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]X_/;deg[X]>2&&AntisymQ[X],Y1___?deg2revParityQ,z_?deg1Q\[RightAngleBracket],Y2__\[RightAngleBracket]:=revSignAntisym[deg[X]-2]\[LeftAngleBracket]z,rev[X,Y1],Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
ruleToTest =AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2Q,v1_?deg1Q\[RightAngleBracket],Y2___?deg2revParityQ,v2_?deg1Q\[RightAngleBracket]:=\[LeftAngleBracket]v2,rev[Y2],Y1,v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v2_?deg1Q,Y2___?deg2revParityQ,\[LeftAngleBracket]v1_?deg1Q,Y1__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]v1,Y1,rev[Y2],v2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2Q,v1_?deg1Q\[RightAngleBracket],Y2___?deg2revParityQ,X_?AntisymQ\[RightAngleBracket]:=revSignAntisym[deg[X]-1]\[LeftAngleBracket]rev[Y2,X],Y1,v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]X_?AntisymQ,Y2___?deg2revParityQ,\[LeftAngleBracket]v1_?deg1Q,Y1__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=revSignAntisym[deg[X]-1]\[LeftAngleBracket]v1,Y1,rev[X,Y2]\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2Q,v1_?deg1Q\[RightAngleBracket],Y2___?deg2revParityQ,X_?AntisymQ,Y3___?deg2revParityQ,v2_?deg1Q\[RightAngleBracket]:=-\[LeftAngleBracket]v2,rev[Y3],X,rev[Y2],Y1,v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v2_?deg1Q,Y3___?deg2revParityQ,X_?AntisymQ,Y2___?deg2revParityQ,\[LeftAngleBracket]v1_?deg1Q,Y1__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=-\[LeftAngleBracket]v1,Y1,rev[Y2],X,rev[Y3],v2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2Q,v1_?deg1Q\[RightAngleBracket],Y2___?deg2revParityQ,X_?SymQ\[RightAngleBracket]:=\[LeftAngleBracket]X,rev[Y2],Y1,v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]X_?SymQ,Y2___?deg2revParityQ,\[LeftAngleBracket]v1_?deg1Q,Y1__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]v1,Y1,rev[Y2],X\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]Y1__?deg2Q,v1_?deg1Q\[RightAngleBracket],Y2___?deg2revParityQ,X_?SymQ,Y3___?deg2revParityQ,v2_?deg1Q\[RightAngleBracket]:=\[LeftAngleBracket]v2,rev[Y3],X,rev[Y2],Y1,v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v2_?deg1Q,Y3___?deg2revParityQ,X_?SymQ,Y2___?deg2revParityQ,\[LeftAngleBracket]v1_?deg1Q,Y1__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]v1,Y1,rev[Y2],X,rev[Y3],v2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X_,v_?deg1Q\[RightAngleBracket]\[RightAngleBracket], ab__List]:=\[LeftAngleBracket]Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab],v\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]\[LeftAngleBracket]v_?deg1Q,X_\[RightAngleBracket]\[RightAngleBracket], ab__List]:=\[LeftAngleBracket]v,Subscript[\[LeftAngleBracket]X\[RightAngleBracket], Apply[Sequence,{ab}+1]]\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]M__?deg2Q, F1_?deg3Q, X__\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=\[LeftAngleBracket]
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]M, F1\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\),X\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X__,F1_?deg3Q,M__?deg2Q\[RightAngleBracket]\[RightAngleBracket], ab_List]/;ab==={degBracket[X],degBracket[X,F1,M]}:=\[LeftAngleBracket]X,
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]F1, M\[RightAngleBracket]\[RightAngleBracket]\), \({2, degBracket[F1, M]}\)]\)\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]S_?deg2Q, \[CurlyEpsilon]4, u_?deg1Q\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=\[LeftAngleBracket]
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]S, \[CurlyEpsilon]4\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\),u\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]\[LeftAngleBracket]X_?deg3Q, v_?deg1Q\[RightAngleBracket], Y_?deg2Q\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=\[LeftAngleBracket]
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]Y, X\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\),v\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v_?deg1Q,Subscript[\[LeftAngleBracket]X1_\[CircleTimes]X2___\[RightAngleBracket], ab__List],Y__\[RightAngleBracket]/;!MemberQ[{ab},1,{2}]:= \[LeftAngleBracket]Subscript[\[LeftAngleBracket]\[LeftAngleBracket]v,X1\[RightAngleBracket]\[CircleTimes]X2\[RightAngleBracket], Apply[Sequence,{ab}-1]],Y\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v_?deg1Q,Subscript[\[LeftAngleBracket]X1_\[CircleTimes]X2___\[RightAngleBracket], ab__List]\[RightAngleBracket]/;!MemberQ[{ab},1,{2}]:= Subscript[\[LeftAngleBracket]\[LeftAngleBracket]v,X1\[RightAngleBracket]\[CircleTimes]X2\[RightAngleBracket], Apply[Sequence,{ab}-1]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y__,Subscript[\[LeftAngleBracket]X1___\[CircleTimes]X2_\[RightAngleBracket], ab__List],v_?deg1Q\[RightAngleBracket]/;!MemberQ[{ab},deg[X1]+deg[X2],{2}]:= \[LeftAngleBracket]Y,Subscript[\[LeftAngleBracket]X1\[CircleTimes]\[LeftAngleBracket]X2,v\[RightAngleBracket]\[RightAngleBracket], ab]\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Subscript[\[LeftAngleBracket]X1___\[CircleTimes]X2_\[RightAngleBracket], ab__List],v_?deg1Q\[RightAngleBracket]/;!MemberQ[{ab},deg[X1]+deg[X2],{2}]:= Subscript[\[LeftAngleBracket]X1\[CircleTimes]\[LeftAngleBracket]X2,v\[RightAngleBracket]\[RightAngleBracket], ab]]


(* ::Input::Initialization:: *)
AddRule[ rev[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]]:= Subscript[\[LeftAngleBracket]rev[X]\[RightAngleBracket], Apply[Sequence,deg[X]+1-{ab}]]]


(* ::Input::Initialization:: *)
AddRule[ rev[a_AngleBracket/;Length[a]>1]:= Apply[AngleBracket,rev[Apply[List,a]]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]X_?deg1Q,Y_?deg1Q\[RightAngleBracket]/;!OrderedAkaQ[X,Y]:=\[LeftAngleBracket]Y,X\[RightAngleBracket]]


(* ::Input::Initialization:: *)
Aka[X_?FieldQ]:=Hold[X,X]


(* ::Input::Initialization:: *)
Aka[X_Symbol]:=Hold[X,X]


(* ::Input::Initialization:: *)
Aka[\[GothicCapitalD][X_,n___]]:=Hold[X,\[GothicCapitalD][X,n]]


(* ::Input::Initialization:: *)
Aka[pD[X_,n___]]:=Hold[X,pD[X,n]]


(* ::Input::Initialization:: *)
Aka[X_List]:=Map[Aka,X]


(* ::Input::Initialization:: *)
OrderedAkaQ[X_,Y_]:= OrderedQ[{Aka[X],Aka[ Y]}]
OrderedAkaQ[X_List]:=OrderedQ[Map[Aka,X]]


(* ::Input::Initialization:: *)
AddRule[ListOfrevs[f_]:=Sort[Reap[f/.rev[x_]:>Sow[rev[x]];][[2]]]]


(* ::Input::Initialization:: *)
AddRule[revOrderedQ[f_]:=OrderedQ[{ListOfrevs[f],ListOfrevs[rev[f]]}]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]X__/; Length[{X}]>1&&DependsQ[{X},rev]&&Same0or1Q[degBracket[X]]&&!revEvenQ[X]&&!revOrderedQ[{X}]\[RightAngleBracket]:=Apply[AngleBracket, rev[{X}]]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]z_?deg1Q,\[LeftAngleBracket]_?deg1Q,___?deg2Q,_?AntisymQ,z_\[RightAngleBracket]\[RightAngleBracket]:=0]
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]z_?deg1Q,_?AntisymQ,___?deg2Q,_?deg1Q\[RightAngleBracket],z_\[RightAngleBracket]:=0]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]___,\[LeftAngleBracket]___,F_?AntisymQ/;deg[F]>2,z_?deg1Q\[RightAngleBracket],z_\[RightAngleBracket]:=0]
AddRule[\[LeftAngleBracket]z_?deg1Q,\[LeftAngleBracket]z_,F_?AntisymQ/;deg[F]>2,___\[RightAngleBracket],___\[RightAngleBracket]:=0]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]M__?deg2Q,w_?deg1Q\[RightAngleBracket],z_?deg1Q\[RightAngleBracket]:=\[LeftAngleBracket]z,M,w\[RightAngleBracket]]
AddRule[\[LeftAngleBracket]z_?deg1Q,\[LeftAngleBracket]w_?deg1Q,M__?deg2Q\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]w,M,z\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]M1__?deg2revParityQ, rev[X_?deg2Q], M2__?deg2revParityQ\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]rev[M2], X, rev[M1]\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]rev[X_?deg2Q], M___?deg2revParityQ\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]rev[M], X\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)]


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]M___?deg2revParityQ, rev[X_?deg2Q]\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X, rev[M]\[RightAngleBracket]\[RightAngleBracket]\), \({1, 2}\)]\)]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v1_List,v2_\[RightAngleBracket]:=Map[AngleBracket[#,v2]&,v1]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]v1_,v2_List\[RightAngleBracket]:=Map[AngleBracket[v1,#]&,v2]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]x_List\[RightAngleBracket], ab__]:=Map[Subscript[\[LeftAngleBracket]#\[RightAngleBracket], ab]&,x]]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]X_CircleTimes,Y__\[RightAngleBracket]:=Most[X]\[CircleTimes]\[LeftAngleBracket]Last[X],Y\[RightAngleBracket]]
AddRule[0,\[LeftAngleBracket]Y__,X_CircleTimes\[RightAngleBracket]:=\[LeftAngleBracket]Y,First[X]\[RightAngleBracket]\[CircleTimes]Rest[X]]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]Y1__,X_CircleTimes/;Length[X]===2,Y2__\[RightAngleBracket]:=\[LeftAngleBracket]Y1,First[X]\[RightAngleBracket]\[CircleTimes]\[LeftAngleBracket]Last[X],Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[0,\[LeftAngleBracket]Y1__,X_CircleTimes/;Length[X]>2,Y2__\[RightAngleBracket]:=\[LeftAngleBracket]Y1,First[X]\[RightAngleBracket]\[CircleTimes]Most[Rest[X]]\[CircleTimes]\[LeftAngleBracket]Last[X],Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
ToList[x_]:=Module[{h},
h=Hold[x];
h=h//.{Plus->List,Times->List,CircleTimes->List,Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], __]:>X,AngleBracket->List};
Flatten[{ReleaseHold[h]}]]


(* ::Input::Initialization:: *)
revCount[Y__]:=Count[ToList[{Y}],_rev]


(* ::Input::Initialization:: *)
revQ[Y__]:= Module[{Ylist,revYlist},
Ylist=ToList[{Y}];
revYlist=ToList[rev[{Y}]];
Count[Ylist,_rev]>Count[revYlist,_rev]]


(* ::Input::Initialization:: *)
revEQ[Y__]:= Module[{Ylist,revYlist},
Ylist=ToList[{Y}];
revYlist=ToList[rev[{Y}]];
Count[Ylist,_rev]>=Count[revYlist,_rev]]


(* ::Input::Initialization:: *)
FieldWithoutSymQ[x_]:= FieldQ[x]&&!HasSymQ[x]


(* ::Input::Initialization:: *)
FieldWithoutSymCount[Y__]:= Apply[Plus,Map[If[FieldWithoutSymQ[#],1,0]&,{Y}]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]M_?AntisymQ,v_?deg1Q\[RightAngleBracket],Y__?deg1or2Q\[RightAngleBracket]:=(-1)^(deg[M]-1) \[LeftAngleBracket]v,M,Y\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]\[LeftAngleBracket]M_?SymQ,v_?deg1Q\[RightAngleBracket],Y__?deg1or2Q\[RightAngleBracket]:=\[LeftAngleBracket]v,M,Y\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y__?deg1or2Q,\[LeftAngleBracket]v_?deg1Q,M_?AntisymQ\[RightAngleBracket]\[RightAngleBracket]:=(-1)^(deg[M]-1) \[LeftAngleBracket]Y,M,v\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[\[LeftAngleBracket]Y__?deg1or2Q,\[LeftAngleBracket]v_?deg1Q,M_?SymQ\[RightAngleBracket]\[RightAngleBracket]:=\[LeftAngleBracket]Y,M,v\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]Y1_\[CircleTimes]Y2_\[RightAngleBracket], a_,b_]/;b===a+1&&a===deg[Y1]:=\[LeftAngleBracket]Y1,Y2\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]v1_?deg1Q\[CircleTimes]v2__\[RightAngleBracket], 1,b_]/; b===1+deg[v2]:=\[LeftAngleBracket]CircleTimes[v2],v1\[RightAngleBracket]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]v1__\[CircleTimes]v2_?deg1Q\[RightAngleBracket], 1,b_]/; b===1+deg[v1]:=\[LeftAngleBracket]v2,CircleTimes[v1]\[RightAngleBracket]]


(* ::Input::Initialization:: *)
PrintRulesUsedList = False;


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[

\!\(\*SubscriptBox[\(\[LeftAngleBracket]v_\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===b:=(
Print[HoldForm[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]v\[RightAngleBracket]\), \({a, b}\)]\)],"  \[LongLeftArrow] Contraction slots must differ."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]];
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[

\!\(\*SubscriptBox[\(\[LeftAngleBracket]v_\[RightAngleBracket]\), \({a_, b_}\)]\)/; a<1|| b<1||a>deg[v]||b>deg[v]:=(
Print[HoldForm[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]v\[RightAngleBracket]\), \({a, b}\)]\)],"  \[LongLeftArrow] Contraction slots are out of range."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]];
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[

\!\(\*SubscriptBox[\(\[LeftAngleBracket]v_?deg1Q\[RightAngleBracket]\), \({a_, b_}\)]\):=(
Print[HoldForm[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]v\[RightAngleBracket]\), \({a, b}\)]\)],"  \[LongLeftArrow] Contraction is not defined for single vectors (arguments of degree 1)."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]];
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[

\!\(\*SubscriptBox[\(\[LeftAngleBracket]v_?deg0Q\[RightAngleBracket]\), \({a_, b_}\)]\):=(
Print[HoldForm[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]v\[RightAngleBracket]\), \({a, b}\)]\)],"  \[LongLeftArrow] Contraction is not defined for scalars (arguments of degree 0)."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]];
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
\[LeftAngleBracket]v__\[RightAngleBracket]/;Length[{v}]>2&&Apply[Or,deg0Q[{v}]]:= (
Print[HoldForm[\[LeftAngleBracket]v\[RightAngleBracket]],"  \[LongLeftArrow] Contraction is not defined for scalars (arguments of degree 0)."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]]; 
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
\[LeftAngleBracket]X1__,v_?deg1Q,X2__\[RightAngleBracket]:= (
Print[HoldForm[\[LeftAngleBracket]v\[RightAngleBracket]],"  \[LongLeftArrow] Vectors can only appear as the first and/or last argument in the conraction bracket."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]]; 
Abort[])]]


(* ::Input::Initialization:: *)
ArgumentCheck[AddRule[
\[LeftAngleBracket]v__/;Length[{v}]>1&&degBracket[v]<0\[RightAngleBracket]:= (
Print[HoldForm[\[LeftAngleBracket]v\[RightAngleBracket]],"  \[LongLeftArrow] Calculated bracket degree is < 0 ??. Try using degCheck[ ]."];
If[PrintRulesUsedList,Print["RulesUsedList = ",RulesUsedList]]; 
Abort[])]]


(* ::Input::Initialization:: *)
If[TrueQ[$PrintDebugLocation],Print["End of Part1"]] 
SaveInitTime[] 
