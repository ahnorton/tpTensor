(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
Clear[struts]
struts[expr_Plus]:=Union[Flatten[Map[struts,Apply[List,expr]]]]
struts[c_ expr_]:=struts[expr]/;deg[c]==0
struts[expr_CircleTimes]:={expr}
struts[c_]:={1}/;deg[c]==0
struts[c_]:={c}/;IntegerQ[deg[c]]&&deg[c]!=0


(* ::Input::Initialization:: *)
Clear[Strut1Coeff]
Clear[strutCoefficient]
strutCoefficient[X_,s_]:=If[!FreeQ[s,SeriesData],
Print["strutCoefficient: The strut (2nd argument in strutCoefficient[]) must be FreeQ of SeriesData."];
Return[Hold[ strutCoefficient[X,s]]],
If[s===1,Strut1Coeff,Coefficient[X,s]]]


(* ::Input::Initialization:: *)
Clear[strutPair]
strutPair[X_]:=Module[{y,c,s,p},
s = struts[X];
If[!Apply[And,Map[IntegerQ,deg[Flatten[s]]]],Print["Not all struts have well defined degree."];Abort[]];
c=Map[strutCoefficient[X,#]&,s];
If[MemberQ[c,Strut1Coeff], 
p=First[First[Position[c,Strut1Coeff,{1},Heads->False]]];
y = c.s/.Strut1Coeff->0;
c[[p]]=X-y;];
{s,c}]


(* ::Input::Initialization:: *)
Clear[costruts]
costruts[X_]:=strutPair[X][[2]]


(* ::Input::Initialization:: *)
SetAttributes[SimplifyTensor,Listable]


(* ::Input::Initialization:: *)
Clear[SimplifyTensor]
SimplifyTensor[X_,opt___]:= Module[{s,c},{s,c}=strutPair[X];Simplify[c,opt].s]


(* ::Input::Initialization:: *)
SetAttributes[FullSimplifyTensor,Listable]


(* ::Input::Initialization:: *)
Clear[FullSimplifyTensor]
FullSimplifyTensor[X_,opt___]:= Module[{s,c},{s,c}=strutPair[X];FullSimplify[c,opt].s]


(* ::Input::Initialization:: *)
SetAttributes[StrutedTensor,Listable]
Clear[StrutedTensor]
StrutedTensor[X_]:= Module[{s,c},{s,c}=strutPair[X];c.s] 


(* ::Input::Initialization:: *)
SetAttributes[ExpandTensor,Listable]
Clear[ExpandTensor]
ExpandTensor[X_]:= Module[{s,c},{s,c}=strutPair[X];Expand[c].s]


(* ::Input::Initialization:: *)
SetAttributes[ExpandAllTensor,Listable]
Clear[ExpandAllTensor]
ExpandAllTensor[X_]:= Module[{s,c},{s,c}=strutPair[X];ExpandAll[c].s]


(* ::Input::Initialization:: *)
SetAttributes[FactorTensor,Listable]
Clear[FactorTensor]
FactorTensor[X_]:= Module[{s,c},{s,c}=strutPair[X];Factor[c].s]


(* ::Input::Initialization:: *)
SimplifyTensor[X_SeriesData,opt___]:= MapAt[Map[SimplifyTensor[#,opt]&,#]&,X,3]


(* ::Input::Initialization:: *)
FullSimplifyTensor[X_SeriesData,opt___]:= MapAt[Map[FullSimplifyTensor[#,opt]&,#]&,X,3]


(* ::Input::Initialization:: *)
StrutedTensor[X_SeriesData]:= MapAt[Map[StrutedTensor,#]&,X,3]


(* ::Input::Initialization:: *)
ExpandTensor[X_SeriesData]:= MapAt[Map[ExpandTensor,#]&,X,3]


(* ::Input::Initialization:: *)
ExpandAllTensor[X_SeriesData]:= MapAt[Map[ExpandAllTensor,#]&,X,3]


(* ::Input::Initialization:: *)
FactorTensor[X_SeriesData]:= MapAt[Map[FactorTensor,#]&,X,3]


(* ::Input::Initialization:: *)
struts[c_List]:=Map[struts,c]


(* ::Input::Initialization:: *)
costruts[c_List]:=Map[costruts,c]


(* ::Input::Initialization:: *)
strutPair[c_List]:=Map[strutPair,c]


(* ::Input::Initialization:: *)
struts[X_SeriesData] := struts[X[[3]]]


(* ::Input::Initialization:: *)
Clear[PolyToSeries]
PolyToSeries[y_,\[CurlyEpsilon]_Symbol,max_Integer]:=Module[{n},
If[!PolynomialQ[y,\[CurlyEpsilon]],Print["Non-polynomial argument."];Abort[]];
If[max >=Exponent[y,\[CurlyEpsilon]],
SeriesData[\[CurlyEpsilon],0,CoefficientList[y,\[CurlyEpsilon]],0,max+1,1],
SeriesData[\[CurlyEpsilon],0,Table[Coefficient[y,\[CurlyEpsilon],n],{n,0,max}],0,max+1,1]]]


(* ::Input::Initialization:: *)
PolyToSeries[y_,\[CurlyEpsilon]_Symbol]:=PolyToSeries[y,\[CurlyEpsilon],Exponent[y,\[CurlyEpsilon]]]


(* ::Input::Initialization:: *)
SeriesOrder[s_]:=If[Head[s]===SeriesData,s[[5]],Infinity]
SeriesNmax=SeriesOrder;


(* ::Input::Initialization:: *)
SeriesNmin[s_SeriesData]:=s[[4]]


(* ::Input::Initialization:: *)
SeriesNmin[s_,x_]:=If[Head[s]===SeriesData,s[[4]],Part[O[x]s,4]-1]


(* ::Input::Initialization:: *)
SeriesNmin[s_,x_,x0_]:=If[Head[s]===SeriesData,s[[4]],Part[s SeriesData[x,x0,{},0,0,1],4]]


(* ::Input::Initialization:: *)
SeriesNdiff[s_]:=If[Head[s]===SeriesData,s[[5]]-s[[4]],Infinity]


(* ::Input::Initialization:: *)
CheckSeriesVariable[x_,s_]:=If[Head[s]===SeriesData,
If[!s[[1]]===x,
Print["tpTensor: Series variables SeriesData[ ][[1]] must be the same:"];Print[s[[1]]];Print[x];Abort[]]]


(* ::Input::Initialization:: *)
CheckSeriesPoint[x0_,s_]:=If[Head[s]===SeriesData,
If[!s[[2]]===x0,
Print["tpTensor: Series expansion points SeriesData[ ][[2]] must be the same:"];Print[s[[2]]];Print[x0];Abort[]]]


(* ::Input::Initialization:: *)
CheckSeriesDen[den_,s_]:=If[Head[s]===SeriesData,
If[!s[[6]]===den,
Print["tpTensor: Series denominator SeriesData[ ][[6]] must be the same:"];Print[s[[6]]];Print[den];Abort[]]]


(* ::Input::Initialization:: *)
CheckSeriesHeads[s_]:=If[!Head[s]===SeriesData,
Print["SeriesProduct[ ]: The first argument must be a list of SeriesData[]."];Abort[]]


(* ::Input::Initialization:: *)
CircleTimes[y1___,y_SeriesData,y2___]:=Module[{x,x0,a,nmin,nmax,den,Y1,Y2,ndiff,Oinfty},
{x,x0,nmin,nmax,den} = Apply[List,y][[{1,2,4,5,6}]];
ndiff=nmax-nmin;
Map[CheckSeriesVariable[x,#]&,{y1,y2}];
Map[CheckSeriesPoint[x0,#]&,{y1,y2}];
Map[CheckSeriesDen[den,#]&,{y1,y2}];
ndiff = Min[ndiff,Map[SeriesNdiff,{y1,y2}]];
Oinfty=SeriesData[x,x0,{},1000000000,1000000000,den];
Y1=Map[If[FreeQ[#,x],#+Oinfty,Series[#,{x,x0,SeriesNmin[#,x,x0]+ndiff-1}]]&,{y1}];
Y2=Map[If[FreeQ[#,x],#+Oinfty,Series[#,{x,x0,SeriesNmin[#,x,x0]+ndiff-1}]]&,{y2}];
SeriesProduct[Join[Y1,{y},Y2],CircleTimes]]


(* ::Input::Initialization:: *)
AngleBracket[y1___,y_SeriesData,y2___]/;Length[{y1,y2}]>0:=Module[{x,x0,a,nmin,nmax,den,Y1,Y2,ndiff,Oinfty},
{x,x0,nmin,nmax,den} = Apply[List,y][[{1,2,4,5,6}]];
ndiff=nmax-nmin;
Map[CheckSeriesVariable[x,#]&,{y1,y2}];
Map[CheckSeriesPoint[x0,#]&,{y1,y2}];
Map[CheckSeriesDen[den,#]&,{y1,y2}];
ndiff = Min[ndiff,Map[SeriesNdiff,{y1,y2}]];
Oinfty=SeriesData[x,x0,{},1000000000,1000000000,den];
Y1=Map[If[FreeQ[#,x],#+Oinfty,Series[#,{x,x0,SeriesNmin[#,x,x0]+ndiff-1}]]&,{y1}];
Y2=Map[If[FreeQ[#,x],#+Oinfty,Series[#,{x,x0,SeriesNmin[#,x,x0]+ndiff-1}]]&,{y2}];
SeriesProduct[Join[Y1,{y},Y2],AngleBracket]]


(* ::Input::Initialization:: *)
SeriesProduct[y_List,prod_]:=Module[{a,x,x0,nmin,nmax,den,p,i,j,n1min,n1max,n2min,n2max,a1,a2,n,n1,n2,y1,y2,j1max,j2max,j1,j2},
Map[CheckSeriesHeads,y];
If[Length[y]===1,Return[y[[1]]]];
y1=Apply[List,y[[1]]];
y2=Apply[List,y[[2]]];
{x,x0,n1min,n1max,den} = y1[[{1,2,4,5,6}]];
CheckSeriesVariable[x,y[[2]]];
CheckSeriesPoint[x0,y[[2]]];
CheckSeriesDen[den,y[[2]]];
{n2min,n2max} = y2[[{4,5}]];
nmin = n1min+n2min;
nmax = Min[n1max+n2min,n2max+n1min];
a1=y1[[3]];
a2=y2[[3]];
j1max=Length[a1];
j2max=Length[a2];
a= Table[0,{j1max j2max}];
Do[
n = (j1-1+n1min)+(j2-1+n2min);
If[n<=nmax-1,
a[[n-nmin+1]]+=prod[Part[a1,j1],Part[a2,j2]]
],
{j1,j1max},
{j2,j2max}];
If[Length[y]===2,Return[SeriesData[x,x0,a,nmin,nmax,den]]];
SeriesProduct[Prepend[Rest[Rest[y]],SeriesData[x,x0,a,nmin,nmax,den]],prod]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]X_SeriesData\[RightAngleBracket], ab__List]:= MapAt[Map[Subscript[\[LeftAngleBracket]#\[RightAngleBracket], ab]&,#]&,X,3]]


(* ::Input::Initialization:: *)
SetAttributes[Del,Listable]


(* ::Input::Initialization:: *)
deg[\[Del] v_]:=deg[v]+1


(* ::Input::Initialization:: *)
Del[a_?NumericQ]=0;


(* ::Input::Initialization:: *)
Del[v_Plus]:=Map[Del,v]


(* ::Input::Initialization:: *)
Del[f1_ f2_]:= Expand[f1\[CircleTimes]\[Del]f2 + f2\[CircleTimes]\[Del]f1]


(* ::Input::Initialization:: *)
AddRule[\[Del]v_CircleTimes:=mvToLast[deg[First[v]]+1,\[Del]First[v]\[CircleTimes]Rest[v]]+First[v]\[CircleTimes]\[Del]Rest[v]]


(* ::Input::Initialization:: *)
Del[Sin[f_?deg0Q]]:=  Cos[f] Del[f]
Del[Cos[f_?deg0Q]]:=-Sin[f] Del[f]

Del[Csc[f_?deg0Q]]:=-Cot[f] Csc[f] Del[f]
Del[Sec[f_?deg0Q]]:=   Sec[f] Tan[f]Del[f]

Del[Tan[f_?deg0Q]]:=   Sec[f]^2 Del[f]
Del[Cot[f_?deg0Q]]:= -Csc[f]^2 Del[f]


(* ::Input::Initialization:: *)
Del[(a_?deg0Q)^b_?deg0Q]:=b a^(b-1) Del[a]+a^b Log[a] Del[b]


(* ::Input::Initialization:: *)
AddRule[\[Del]Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]:= Subscript[\[LeftAngleBracket]\[Del]X\[RightAngleBracket], ab]]


(* ::Input::Initialization:: *)
AddRule[\[Del]\[LeftAngleBracket]X_?deg1Q,Y_\[RightAngleBracket]:=\[LeftAngleBracket]X,\[Del]Y\[RightAngleBracket]+ 
\!\(\*SubscriptBox[\(\[LeftAngleBracket]Y\[CircleTimes]\[Del]X\[RightAngleBracket]\), \({1, deg[Y] + 1}\)]\)]


(* ::Input::Initialization:: *)
AddRule[\[Del]\[LeftAngleBracket]X_,Y_\[RightAngleBracket]:=\[LeftAngleBracket]X,\[Del]Y\[RightAngleBracket]+ mvToLast[deg[X],
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[Del]X\[CircleTimes]Y\[RightAngleBracket]\), \({deg[X], deg[X] + 2}\)]\)]]


(* ::Input::Initialization:: *)
AddRule[\[Del](a_AngleBracket/;Length[a]>2 &&deg[First[a]]===1):=\[LeftAngleBracket]First[a],\[Del]Rest[a]\[RightAngleBracket]+
\!\(\*SubscriptBox[\(\[LeftAngleBracket]Rest[a]\[CircleTimes]\[Del]First[a]\[RightAngleBracket]\), \({1, deg[Rest[a]] + 1}\)]\)]


(* ::Input::Initialization:: *)
AddRule[\[Del](a_AngleBracket/;Length[a]>2):=\[LeftAngleBracket]First[a],\[Del]Rest[a]\[RightAngleBracket]+mvToLast[deg[First[a]],
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[Del]First[a]\[CircleTimes]Rest[a]\[RightAngleBracket]\), \({deg[First[a]], deg[First[a]] + 2}\)]\)]]


(* ::Input::Initialization:: *)
AddRule[\[Del]mv[n__][X_]:=mv[n][\[Del]X]]


(* ::Input::Initialization:: *)
AddRule[\[Del]mvToLast[n_,X_]:=mvToLast[deg[X],mvToLast[n][\[Del]X]]]


(* ::Input::Initialization:: *)
AddRule[\[Del]f_SeriesData := Series[\[Del]Normal[f],{f[[1]],f[[2]],f[[5]]-2}]]


(* ::Input::Initialization:: *)
CustomTeX[grad,"\\nabla^\\sharp"];


(* ::Input::Initialization:: *)
Clear[grad]


(* ::Input::Initialization:: *)
grad/:MakeBoxes[grad[x_],StandardForm]:=RowBox[{SuperscriptBox["\[Del]","\[Sharp]"],ToBoxes[x,StandardForm]}]


(* ::Input::Initialization:: *)
MakeExpression[RowBox[{SuperscriptBox["\[Del]","\[Sharp]"],x_}],StandardForm]:=MakeExpression[RowBox[{"grad[",x,"]"}],StandardForm]


(* ::Input::Initialization:: *)
DelTograd = {\[Del]($X_):>\[LeftAngleBracket]grad[$X],Metric[]\[RightAngleBracket]};


(* ::Input::Initialization:: *)
gradToDel ={grad[$X_]:>\[LeftAngleBracket]\[Del]$X,MetricInverse[]\[RightAngleBracket]};


(* ::Input::Initialization:: *)
SetAttributes[grad,Listable]


(* ::Input::Initialization:: *)
deg[grad[ v_]]:=deg[v]+1


(* ::Input::Initialization:: *)
grad[a_?NumericQ]=0;


(* ::Input::Initialization:: *)
grad[v_Plus]:=Map[grad,v]


(* ::Input::Initialization:: *)
grad[f1_ f2_]:= Expand[f1\[CircleTimes]grad[f2] + f2\[CircleTimes]grad[f1]]


(* ::Input::Initialization:: *)
AddRule[grad[v_CircleTimes]:=mvToLast[deg[First[v]]+1,grad[First[v]]\[CircleTimes]Rest[v]]+First[v]\[CircleTimes]grad[Rest[v]]]


(* ::Input::Initialization:: *)
grad[Sin[f_?deg0Q]]:=  Cos[f] grad[f]
grad[Cos[f_?deg0Q]]:=-Sin[f] grad[f]

grad[Csc[f_?deg0Q]]:=-Cot[f] Csc[f] grad[f]
grad[Sec[f_?deg0Q]]:=   Sec[f] Tan[f]grad[f]

grad[Tan[f_?deg0Q]]:=   Sec[f]^2 grad[f]
grad[Cot[f_?deg0Q]]:= -Csc[f]^2 grad[f]


(* ::Input::Initialization:: *)
grad[(a_?deg0Q)^b_?deg0Q]:=b a^(b-1) grad[a]+a^b Log[a] grad[b]


(* ::Input::Initialization:: *)
AddRule[grad[Subscript[\[LeftAngleBracket]X_\[RightAngleBracket], ab__List]]:= Subscript[\[LeftAngleBracket]grad[X]\[RightAngleBracket], ab]]


(* ::Input::Initialization:: *)
AddRule[grad[\[LeftAngleBracket]X_?deg1Q,Y_\[RightAngleBracket]]:=\[LeftAngleBracket]X,grad[Y]\[RightAngleBracket]+ 
\!\(\*SubscriptBox[\(\[LeftAngleBracket]Y\[CircleTimes]grad[X]\[RightAngleBracket]\), \({1, deg[Y] + 1}\)]\)]


(* ::Input::Initialization:: *)
AddRule[grad[\[LeftAngleBracket]X_,Y_\[RightAngleBracket]]:=\[LeftAngleBracket]X,grad[Y]\[RightAngleBracket]+ mvToLast[deg[X],
\!\(\*SubscriptBox[\(\[LeftAngleBracket]grad[X]\[CircleTimes]Y\[RightAngleBracket]\), \({deg[X], deg[X] + 2}\)]\)]]


(* ::Input::Initialization:: *)
AddRule[grad[a_AngleBracket/;Length[a]>2 &&deg[First[a]]===1]:=\[LeftAngleBracket]First[a],grad[Rest[a]]\[RightAngleBracket]+
\!\(\*SubscriptBox[\(\[LeftAngleBracket]Rest[a]\[CircleTimes]grad[First[a]]\[RightAngleBracket]\), \({1, deg[Rest[a]] + 1}\)]\)]


(* ::Input::Initialization:: *)
AddRule[grad[a_AngleBracket/;Length[a]>2]:=\[LeftAngleBracket]First[a],grad[Rest[a]]\[RightAngleBracket]+mvToLast[deg[First[a]],
\!\(\*SubscriptBox[\(\[LeftAngleBracket]grad[First[a]]\[CircleTimes]Rest[a]\[RightAngleBracket]\), \({deg[First[a]], deg[First[a]] + 2}\)]\)]]


(* ::Input::Initialization:: *)
AddRule[grad[mv[n__][X_]]:=mv[n][grad[X]]]


(* ::Input::Initialization:: *)
AddRule[grad[mvToLast[n_,X_]]:=mvToLast[deg[X],mvToLast[n][grad[X]]]]


(* ::Input::Initialization:: *)
AddRule[grad[f_SeriesData] := Series[grad[Normal[f]],{f[[1]],f[[2]],f[[5]]-2}]]


(* ::Input::Initialization:: *)
AddRule[grad[X_/;ValueQ[\[Del]X]]:=\[LeftAngleBracket]\[Del]X,MetricInverse[]\[RightAngleBracket]/.{\[Del]Y_:>\[LeftAngleBracket]grad[Y],Metric[]\[RightAngleBracket]}]


(* ::Input::Initialization:: *)
div[f_]:=
If[Last[SlotType[f]]===Tangent[Manifold[]],
ExpandTensor[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]grad[f]\[RightAngleBracket]\), \({deg[f], deg[f] + 1}\)]\)],
ExpandTensor[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[Del]f\[RightAngleBracket]\), \({deg[f], deg[f] + 1}\)]\)]]


(* ::Input::Initialization:: *)
curl[v_]:=
If[Last[SlotType[v]]===Tangent[Manifold[]],
ExpandTensor[mvToLast[deg[v],grad[v]]-grad[v]],
If[Last[SlotType[v]]===Cotangent[Manifold[]],
ExpandTensor[mvToLast[deg[v],\[Del]v]-\[Del]v],
Print["curl: The last slot of the argument has unknown type (vector/covector)."];
Abort[]]]


(* ::Input::Initialization:: *)
TraceFreeSquare[f_]:=Module[{ff},
If[MatchQ[SlotType[f],SlotData[Tangent[_],Tangent[_]]],
ff=StrutedTensor[\[LeftAngleBracket]f,rev[f]\[RightAngleBracket]];
ff-1/4 MetricInverse[] 
\!\(\*SubscriptBox[\(\[LeftAngleBracket]ff\[RightAngleBracket]\), \({1, 2}\)]\),
If[MatchQ[SlotType[f],SlotData[Cotangent[_],Cotangent[_]]],
ff=StrutedTensor[\[LeftAngleBracket]f,rev[f]\[RightAngleBracket]];
ff-1/4 Metric[] 
\!\(\*SubscriptBox[\(\[LeftAngleBracket]ff\[RightAngleBracket]\), \({1, 2}\)]\),
Print["TraceFreeSquare: Argument should be a section of ",
\!\(\*SuperscriptBox[\(Tangent[Manifold[]]\), \("\<\[CircleTimes]2\>"\)]\)," or ",
\!\(\*SuperscriptBox[\(Cotangent[Manifold[]]\), \("\<\[CircleTimes]2\>"\)]\),"."];
Abort[]]]]


(* ::Input::Initialization:: *)
Quiet[ClearField[\[Delta]]]


(* ::Input::Initialization:: *)
\[Delta][_,0]:=1
\[Delta][n_,1]:=\[Delta][n]


(* ::Input::Initialization:: *)
FieldType[ \[Delta][n_,r_]]:={\[DoubleStruckCapitalR]^n,{{Tangent[\[DoubleStruckCapitalR]^n],r},{Cotangent[\[DoubleStruckCapitalR]^n],r}}}
FieldType[ \[Delta][n_]]:={\[DoubleStruckCapitalR]^n,{{Tangent[\[DoubleStruckCapitalR]^n],1},{Cotangent[\[DoubleStruckCapitalR]^n],1}}}


(* ::Input::Initialization:: *)
SlotType[\[Delta][n_,r_]]:=Apply[SlotData,Join[Table[Tangent[\[DoubleStruckCapitalR]^n],{r}],Table[Cotangent[\[DoubleStruckCapitalR]^n],{r}]]]
SlotType[\[Delta][n_]]:=SlotData[Tangent[\[DoubleStruckCapitalR]^n],Cotangent[\[DoubleStruckCapitalR]^n]]


(* ::Input::Initialization:: *)
deg[\[Delta][_,r_]]:=2r
deg[\[Delta][_]]:=2


(* ::Input::Initialization:: *)
FieldQ[\[Delta][_,_]]:=True
FieldQ[\[Delta][_]]:=True


(* ::Input::Initialization:: *)
\[Del]\[Delta][_,_]:=0
\[Del]\[Delta][_]:=0


(* ::Input::Initialization:: *)
\[GothicCapitalD][\[Delta][_,_]]:=0
\[GothicCapitalD][\[Delta][_]]:=0


(* ::Input::Initialization:: *)
pD[\[Delta][_,_],__]:=0
pD[\[Delta][_],__]:=0


(* ::Input::Initialization:: *)
AddRule[
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[Delta][n_, r_]\[RightAngleBracket]\), \({a_, b_}\)]\)/;a<=r&&b>r:=(-1)^(a+(b-r)) (n-r+1)\[Delta][n,r-1]]


(* ::Input::Initialization:: *)
AddRule[Subscript[\[LeftAngleBracket]\[Delta][n_,r_]\[RightAngleBracket], ab__List,{a_,b_}]/;a<=r&&b>r:=(-1)^(a+(b-r)) (n-r+1)Subscript[\[LeftAngleBracket]\[Delta][n,r-1]\[RightAngleBracket], abDrop[{ab},{a,b}]]]


(* ::Input::Initialization:: *)
\[LeftAngleBracket]\[Delta][_],X_\[RightAngleBracket]/;MatchQ[First[SlotType[X]],Tangent[_]]:=X
\[LeftAngleBracket]\[Delta][_],X_,Y__\[RightAngleBracket]/;MatchQ[First[SlotType[X]],Tangent[_]]:=\[LeftAngleBracket]X,Y\[RightAngleBracket]
\[LeftAngleBracket]\[Delta][_],X_,Y___\[RightAngleBracket]/;MatchQ[First[SlotType[X]],Cotangent[_]]:=\[LeftAngleBracket]MetricInverse[Manifold[X]],X,Y\[RightAngleBracket]

\[LeftAngleBracket]X_,\[Delta][_]\[RightAngleBracket]/;MatchQ[Last[SlotType[X]],Cotangent[_]]:=X
\[LeftAngleBracket]Y__,X_,\[Delta][_]\[RightAngleBracket]/;MatchQ[Last[SlotType[X]],Cotangent[_]]:=\[LeftAngleBracket]Y,X\[RightAngleBracket]
\[LeftAngleBracket]Y___,X_,\[Delta][_]\[RightAngleBracket]/;MatchQ[Last[SlotType[X]],Tangent[_]]:=\[LeftAngleBracket]Y,X,Metric[Manifold[X]]\[RightAngleBracket]


\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[Delta][n_]\[RightAngleBracket]\), \({1, 2}\)]\):=n
Subscript[\[LeftAngleBracket]X1__\[CircleTimes]\[Delta][n_]\[CircleTimes]X2__\[RightAngleBracket], ab1___List,ab_List,ab2___List]/;ab===deg[X1]+{1,2}:=n Subscript[\[LeftAngleBracket]X1\[CircleTimes]X2\[RightAngleBracket], abDrop[{ab1,ab2},ab]];


(* ::Input::Initialization:: *)
Format[\[Delta][n_,r_],StandardForm]:=Subscript[\[Delta], Row[{"(",n,",",r,")"}]]


(* ::Input::Initialization:: *)
Format[\[Delta][n_],StandardForm]:=Subscript[\[Delta], Row[{"(",n,")"}]]


(* ::Input::Initialization:: *)
\[LeftAngleBracket]rev[\[Delta][4]],rev[\[Delta][4]]\[RightAngleBracket]:=rev[\[Delta][4]]


(* ::Input::Initialization:: *)
ClearField[{SignDetMetric[_],DetMetric[_]}]
NewConstant[SignDetMetric[_]]
NewField[0,{DetMetric[_]}]


(* ::Input::Initialization:: *)
Unprotect[Power];
(SignDetMetric[M_]^n_Integer/;EvenQ[n]):=1;
(SignDetMetric[M_]^n_Integer/;OddQ[n])=SignDetMetric[M];
Protect[Power];


(* ::Input::Initialization:: *)
SignDetMetric[]:=SignDetMetric[Manifold[]]


(* ::Input::Initialization:: *)
ClearField[{Metric[_],MetricInverse[_]}]
NewField[{0,2},Metric[_]];
NewField[{2},MetricInverse[_]];


(* ::Input::Initialization:: *)
Clear[NewMetric]
NewMetric[g_]:= NewMetric[g,{}]
NewMetric[g_,{sigs___Integer}]:=NewMetric[Manifold[],{g,ToExpression[ToString[g]<>"inv"]},{sigs}]


(* ::Input::Initialization:: *)
NewMetric[M_,{g_Symbol,ginv_Symbol},{sigs___Integer}]:=Module[{msg1,msg2,msg},
If[!Apply[SameQ,Abs[{1,sigs}]],Return["The metric signature should be a list with elements \[PlusMinus]1."]];
Metric[M]=g;
MetricInverse[M]=ginv;
If [!Length[{sigs}]===0,
MetricSignature[M]={sigs};
];
If [ValueQ[MetricSignature[M]],
dim[M]=Length[MetricSignature[M]];
SignDetMetric[M]=Apply[Times,MetricSignature[M]];
];
NewField[M,{{Cotangent[M],2}},g];
NewField[M,{{Tangent[M],2}},ginv];
\[Del]g:=0;
\[Del]ginv=0;
AssumeSymmetric[{g,ginv}];

g/:\[LeftAngleBracket]g,ginv\[RightAngleBracket]:=mv[2,1][\[Delta][dim[M]]];
ginv/:\[LeftAngleBracket]ginv,g\[RightAngleBracket]:=\[Delta][dim[M]];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]g\[RightAngleBracket]\), \({1, 2}\)]\):=dim[M];

\!\(\*SubscriptBox[\(\[LeftAngleBracket]ginv\[RightAngleBracket]\), \({1, 2}\)]\):=dim[M];
Subscript[\[LeftAngleBracket]X1__\[CircleTimes]g\[CircleTimes]X2__\[RightAngleBracket], ab1___List,ab_List,ab2___List]/;ab===deg[X1]+{1,2}:=dim[M]Subscript[\[LeftAngleBracket]X1\[CircleTimes]X2\[RightAngleBracket], abDrop[{ab1,ab2},ab]];
Subscript[\[LeftAngleBracket]X1__\[CircleTimes]ginv\[CircleTimes]X2__\[RightAngleBracket], ab1___List,ab_List,ab2___List]/;ab===deg[X1]+{1,2}:=dim[M]Subscript[\[LeftAngleBracket]X1\[CircleTimes]X2\[RightAngleBracket], abDrop[{ab1,ab2},ab]];

Subscript[\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[RightAngleBracket], ab1___List,{a1_,b1_},ab2___List,{a2_,b2_},ab3___List]/;SubsetQ[{a1,b1,a2,b2}, deg[X1]+{1,2}]:=Subscript[\[LeftAngleBracket]X1\[CircleTimes]X2\[RightAngleBracket], abDrop[{ab1,ab2,ab3,Complement[{a1,b1,a2,b2}, deg[X1]+{1,2}]},deg[X1]+{1,2}]];
Subscript[\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[RightAngleBracket], ab1___List,{a1_,b1_},ab2___List,{a2_,b2_},ab3___List]/;SubsetQ[{a1,b1,a2,b2}, deg[X1]+{1,2}]:=Subscript[\[LeftAngleBracket]X1\[CircleTimes]X2\[RightAngleBracket], abDrop[{ab1,ab2,ab3,Complement[{a1,b1,a2,b2}, deg[X1]+{1,2}]},deg[X1]+{1,2}]];

Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1__,X_,g\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===degBracket[X1,X]:=Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1,X\[RightAngleBracket]\[RightAngleBracket], ab1,{a,b},ab2];
Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1__,X_,ginv\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===degBracket[X1,X]:=Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1,X\[RightAngleBracket]\[RightAngleBracket], ab1,{a,b},ab2];

Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X_,g\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===deg[X]:=Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab1,{a,b},ab2];
Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X_,ginv\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===deg[X]:=Subscript[\[LeftAngleBracket]X\[RightAngleBracket], ab1,{a,b},ab2];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]g, X_, X1__\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X, X1\[RightAngleBracket]\[RightAngleBracket]\), \({1, b}, ab\)]\);

\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]ginv, X_, X1__\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]X, X1\[RightAngleBracket]\[RightAngleBracket]\), \({1, b}, ab\)]\);


\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]g, X_\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]X\[RightAngleBracket]\), \({1, b}, ab\)]\);

\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]ginv, X_\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\):=
\!\(\*SubscriptBox[\(\[LeftAngleBracket]X\[RightAngleBracket]\), \({1, b}, ab\)]\);


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]g\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1,X]&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1,X]]&&IntegerQ[deg[X2]]:=
mv[Append[Delete[Range[deg[X1,X,X2]],deg[X1,X]],deg[X1,X]]][X1\[CircleTimes]\[LeftAngleBracket]X,g\[RightAngleBracket]\[CircleTimes]X2\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]g\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1]+1&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1]]&&IntegerQ[deg[X,X2]]:=
mv[Append[Delete[Range[deg[X1,X,X2]],deg[X1]+1],deg[X1]+1]][X1\[CircleTimes]\[LeftAngleBracket]g,X\[RightAngleBracket]\[CircleTimes]X2\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2]+3&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2]]:=
mv[Join[Range[deg[X1]],{deg[X1,X2]+1},Range[deg[X1]+1,deg[X1,X2]]]][X1\[CircleTimes]X2\[CircleTimes]\[LeftAngleBracket]g,X\[RightAngleBracket]\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2,X]+2&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2,X]]:=
mv[Join[Range[deg[X1]],{deg[X1,X2,X]},Range[deg[X1]+1,deg[X1,X2,X]-1]]][X1\[CircleTimes]X2\[CircleTimes]\[LeftAngleBracket]X,g\[RightAngleBracket]\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]ginv\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1,X]&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1,X]]&&IntegerQ[deg[X2]]:=
mv[Append[Delete[Range[deg[X1,X,X2]],deg[X1,X]],deg[X1,X]]][X1\[CircleTimes]\[LeftAngleBracket]X,ginv\[RightAngleBracket]\[CircleTimes]X2\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]ginv\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1]+1&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1]]&&IntegerQ[deg[X,X2]]:=
mv[Append[Delete[Range[deg[X1,X,X2]],deg[X1]+1],deg[X1]+1]][X1\[CircleTimes]\[LeftAngleBracket]ginv,X\[RightAngleBracket]\[CircleTimes]X2\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2]+3&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2]]:=
mv[Join[Range[deg[X1]],{deg[X1,X2]+1},Range[deg[X1]+1,deg[X1,X2]]]][X1\[CircleTimes]X2\[CircleTimes]\[LeftAngleBracket]ginv,X\[RightAngleBracket]\[CircleTimes]X3];


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2,X]+2&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2,X]]:=
mv[Join[Range[deg[X1]],{deg[X1,X2,X]},Range[deg[X1]+1,deg[X1,X2,X]-1]]][X1\[CircleTimes]X2\[CircleTimes]\[LeftAngleBracket]X,ginv\[RightAngleBracket]\[CircleTimes]X3];

g/:\[LeftAngleBracket]X1__,g,X2__\[RightAngleBracket]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];
ginv/:\[LeftAngleBracket]X1__,ginv,X2__\[RightAngleBracket]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];

g/:\[LeftAngleBracket]X1__,X2_,g\[RightAngleBracket]/;LastIsCotangentQ[X2,M]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];
g/:\[LeftAngleBracket]X_,g\[RightAngleBracket]/;LastIsCotangentQ[X,M]:=X;
ginv/:\[LeftAngleBracket]X1__,X2_,ginv\[RightAngleBracket]/;LastIsTangentQ[X2,M]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];
ginv/:\[LeftAngleBracket]X_,ginv\[RightAngleBracket]/;LastIsTangentQ[X,M]:=X;

g/:\[LeftAngleBracket]g,X1_,X2__\[RightAngleBracket]/;FirstIsCotangentQ[X1,M]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];
g/:\[LeftAngleBracket]g,X_\[RightAngleBracket]/;FirstIsCotangentQ[X,M]:=X;
ginv/:\[LeftAngleBracket]ginv,X1_,X2__\[RightAngleBracket]/;FirstIsTangentQ[X1,M]:=\[LeftAngleBracket]X1,X2\[RightAngleBracket];
ginv/:\[LeftAngleBracket]ginv,X_\[RightAngleBracket]/;FirstIsTangentQ[X,M]:=X;

\[GothicCapitalD][g]=0;
\[GothicCapitalD][ginv]=0;

Format[ginv,StandardForm]:=Superscript[g,-1];

msg1=If[ValueQ[MetricSignature[M]],
"MetricSignature["<>M<>"] = "<>ToString[MetricSignature[M]],
"MetricSignature["<>M<>"] is arbitrary"
];

msg2=If[ValueQ[dim[M]],
"dim["<>M<>"] = "<>ToString[dim[M]],
"dim["<>M<>"] is arbitrary"
];

msg=Row[{
" Metric[",M,"]\[MediumSpace]=\[ThickSpace]",g,",\n MetricInverse[",M,"]\[MediumSpace]=\[ThickSpace]",ToString[ginv],"\[MediumSpace] (output as\[ThickSpace]",ginv,"),\n ",
msg1,",\n ",
"SignDetMetric[",M,"] = ",SignDetMetric[M],",\n ",
msg2,".\n",
"  \[Del] is metric compatible: " ,HoldForm[\[Del]g=0], ", ",HoldForm[\[Del] ginv=0],".\n",
" \[LeftAngleBracket]\[VeryThinSpace]\[RightAngleBracket] is metric compatible: factors ", g," and ",ginv, " will be assumed as necessary."} ]
]


(* ::Input::Initialization:: *)
FirstIsTangentQ[X_,M_]:=MatchQ[SlotType[X],SlotData[Tangent[M],___]]
FirstIsCotangentQ[X_,M_]:=MatchQ[SlotType[X],SlotData[Cotangent[M],___]]
LastIsTangentQ[X_,M_]:=MatchQ[SlotType[X],SlotData[___,Tangent[M]]]
LastIsCotangentQ[X_,M_]:=MatchQ[SlotType[X],SlotData[___,Cotangent[M]]]


(* ::Input::Initialization:: *)
Metric[]:=Metric[Manifold[]]
MetricInverse[]:=MetricInverse[Manifold[]]
MetricSignature[]:=MetricSignature[Manifold[]]


(* ::Input::Initialization:: *)
Clear[ClearMetric]
ClearMetric[]:=ClearMetric[Manifold[]]
ClearMetric[M_]:=Module[{g,ginv},
If[Head[Metric[M]]===Metric,Return[Row[{"Nothing done: no metric is defined for manifold ",M}]]];
g=Metric[M];
ginv=MetricInverse[M];

\!\(\*SubscriptBox[\(\[LeftAngleBracket]g\[RightAngleBracket]\), \({1, 2}\)]\)=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]ginv\[RightAngleBracket]\), \({1, 2}\)]\)=.;
Subscript[\[LeftAngleBracket]X1__\[CircleTimes]g\[CircleTimes]X2__\[RightAngleBracket], ab1___List,ab_List,ab2___List]/;ab===deg[X1]+{1,2}=.;
Subscript[\[LeftAngleBracket]X1__\[CircleTimes]ginv\[CircleTimes]X2__\[RightAngleBracket], ab1___List,ab_List,ab2___List]/;ab===deg[X1]+{1,2}=.;

Subscript[\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[RightAngleBracket], ab1___List,{a1_,b1_},ab2___List,{a2_,b2_},ab3___List]/;SubsetQ[{a1,b1,a2,b2}, deg[X1]+{1,2}]=.;
Subscript[\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[RightAngleBracket], ab1___List,{a1_,b1_},ab2___List,{a2_,b2_},ab3___List]/;SubsetQ[{a1,b1,a2,b2}, deg[X1]+{1,2}]=.;

Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1__,X_,g\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===degBracket[X1,X]=.;
Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X1__,X_,ginv\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===degBracket[X1,X]=.;

Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X_,g\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===deg[X]=.;
Subscript[\[LeftAngleBracket]\[LeftAngleBracket]X_,ginv\[RightAngleBracket]\[RightAngleBracket], ab1___List,{a_,b_},ab2___List]/;b===deg[X]=.;


\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]g, X_, X1__\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\)=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]ginv, X_, X1__\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\)=.;


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]g\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1,X]&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1,X]]&&IntegerQ[deg[X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]g\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1]+1&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1]]&&IntegerQ[deg[X,X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2]+3&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]g\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2,X]+2&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2,X]]=.;


\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]ginv\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1,X]&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1,X]]&&IntegerQ[deg[X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]X_\[CircleTimes]X2___\[CircleTimes]ginv\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;a===deg[X1]+1&&(b===deg[X1,X,X2]+1||b===deg[X1,X,X2]+2)&&IntegerQ[deg[X1]]&&IntegerQ[deg[X,X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2]+3&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2]]=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]X1___\[CircleTimes]ginv\[CircleTimes]X2___\[CircleTimes]X_\[CircleTimes]X3___\[RightAngleBracket]\), \({a_, b_}\)]\)/;(a===deg[X1]+1||a===deg[X1]+2)&&b===deg[X1,X2,X]+2&&IntegerQ[deg[X1]]&&IntegerQ[deg[X2,X]]=.;


\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]g, X_\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\)=.;

\!\(\*SubscriptBox[\(\[LeftAngleBracket]\[LeftAngleBracket]ginv, X_\[RightAngleBracket]\[RightAngleBracket]\), \({1, b_}, ab___List\)]\)=.;

Format[ginv,StandardForm]=.;
ClearField[Evaluate[{Metric[M],MetricInverse[M]}]];
(* Apply[Clear,Evaluate[{Metric[M],MetricInverse[M]}]]; *)
Metric[M]=.;
MetricInverse[M]=.;
MetricSignature[M]=.;
]


(* ::Input::Initialization:: *)
Distinct[i__]:=Simplify[Apply[And,Map[!Apply[Equal,#]&,Subsets[Sort[{i}],{2}]]]]


(* ::Input::Initialization:: *)
Clear[SignatureFunction];
Clear[SignatureFunction];


(* ::Input::Initialization:: *)
SignatureFunction[f_Symbol, diag_List]:=SignatureFunction[f, diag,0]
SignatureFunction[f_Symbol, diag_List,imin_Integer]:=Module[{},
If[ValueQ[f],Print["SignatureFunction[]: Symbol ",Unevaluated[f], " already has a value."];Abort[]];
If[!Apply[And,Map[(SameQ[1,#]||SameQ[-1,#])&,diag]],
Print["The 2nd argument of SignatureFunction[] should be a list of integers equal to \[PlusMinus]1."];
Print[diag];
Abort[]];
ClearField[f[_,_]];
NewConstant[f[_,_]];
DiagonalSF[f]=diag;
IndexRangeSF[f]= {imin,imin+Length[diag]-1};
f[i_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=i<=IndexRangeSF[\[Eta]][[2]]],j_]:=
(Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];Abort[]);
f[i_,j_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=j<=IndexRangeSF[\[Eta]][[2]]]]:=
(Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];Abort[]);
f[i_,j_]/;Abs[i-j]>IndexRangeSF[f][[2]]-IndexRangeSF[f][[1]]:=
(Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];Abort[]);
f[i_Integer,j_Integer]:=
                 If[IndexRangeSF[f][[1]]<=i<=IndexRangeSF[f][[2]]&&
                   IndexRangeSF[f][[1]]<=j<=IndexRangeSF[f][[2]],
                     If[i===j,DiagonalSF[f][[i-IndexRangeSF[f][[1]]+1]],0], 
                     Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];
                     Abort[]];
f[j_,i_]/;!OrderedQ[{j,i}]:=f[i,j];
f[i_,j_]/;Distinct[i,j]:=0;
If[Apply[SameQ,diag],
f[i_,i_]=diag[[1]],
f/:f[i_,i_]^2:=1];
f/:f[i_,j_]^n_?EvenQ/;n>2:=f[i,j]^2;
f/:f[i_,j_]^n_?OddQ/;n>1:=f[i,j];
]


(* ::Input::Initialization:: *)
Clear[ClearSignatureFunction];
ClearSignatureFunction[f_Symbol]:=Module[{},
Quiet[(
IndexRangeSF[f]=.;
f[i_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=i<=IndexRangeSF[\[Eta]][[2]]],j_]=.;
f[i_,j_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=j<=IndexRangeSF[\[Eta]][[2]]]]=.;
f[i_,j_]/;Abs[i-j]>IndexRangeSF[f][[2]]-IndexRangeSF[f][[1]]=.;
f[i_Integer,j_Integer]=.;
f[j_,i_]/;!OrderedQ[{j,i}]=.;
f[i_,j_]/;Distinct[i,j]=.;
f[i_,i_]=.;
f/:f[i_,i_]^2=.;
f/:f[i_,j_]^n_?EvenQ/;n>2=.;
f/:f[i_,j_]^n_?OddQ/;n>1=.;)];
ClearField[f[_,_]];]


(* ::Input::Initialization:: *)
SignatureFunction[f_Symbol]:=SignatureFunction[f,0]
SignatureFunction[f_Symbol, imin_Integer]:=Module[{},
If[ValueQ[f],Print["Symbol ",Unevaluated[f], " already has a value."];Abort[]];
ClearField[f[_,_]];
NewConstant[f[_,_]];
IndexRangeSF[f]= {imin,Infinity};
f[i_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=i],j_]:=
(Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];Abort[]);
f[i_,j_/;TrueQ[!IndexRangeSF[\[Eta]][[1]]<=j]]:=
(Print["Index out of range ",IndexRangeSF[f]," : ", f,"[",i,",",j,"]"];Abort[]);
f[j_,i_]/;!OrderedQ[{j,i}]:=f[i,j];
f[i_,j_]/;Distinct[i,j]:=0;
f/:f[i_,i_]^2:=1;
f/:f[i_,j_]^n_?EvenQ/;n>2:=f[i,j]^2;
f/:f[i_,j_]^n_?OddQ/;n>1:=f[i,j];
]


(* ::Input::Initialization:: *)
id[frame_,coframe_]:= Total[Map[Apply[CircleTimes,#]&,Transpose[{frame,coframe}]]]


(* ::Input::Initialization:: *)
metric[frame_,coframe_]:=Flatten[Outer[AngleBracket,frame,frame]].Flatten[Outer[CircleTimes,coframe,coframe]]


(* ::Input::Initialization:: *)
If[TrueQ[$PrintDebugLocation],Print["End of Part2"]]
SaveInitTime[]
