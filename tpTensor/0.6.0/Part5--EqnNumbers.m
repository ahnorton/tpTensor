(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
EqnNumbers::usage="
The  EqnNumbers  package is to allow easy manipulation of equations of the form  a == b.  

Equations can be numbered as in a PDF document, and can be assigned labels, as in a LaTeX source file. 
The  EqnNumbers  package is aimed at being able to easily generate a Notebook version of calculations
as they are presented in an accompanying mathematical paper.
"; 


(* ::Input::Initialization:: *)
Eqn::usage="
Eqn[ n ]  =   a == b     where  n   evaluates to a label for the eqn. 

                                      The label can be a string, number, symbol, sequence or expression.  
                                      For example,  n  could be a 2 argument sequence:   Eqn[ 12.3 ,  \"file_v2.pdf\" ].";


(* ::Input::Initialization:: *)
Eqns::usage="
Eqns[ x ]    where  x  is a pattern,  returns the list of  Eqn[ ]  that involve the pattern  x.";


(* ::Input::Initialization:: *)
Ref::usage="
Ref\[VeryThinSpace][ label , n ]   is a declaration that associates eqn labels and eqn numbers (the returned value is Null).

Ref\[VeryThinSpace][ label ]   returns the associated eqn number.

Ref\[VeryThinSpace][ n ]       returns the associated eqn label.";


(* ::Input::Initialization:: *)
Let::usage="
Let[ n ]    in effect converts the  Equal  in   Eqn[ n ]   into a   Set[ ]   assignment,  so that    Eqn[ n ]   is automatically used.
The advantage over just using   Set[ ]   is that one can refer back to   Eqn[ n ]   to see what was done.";


(* ::Input::Initialization:: *)
Unlet::usage="
Unlet[ n ]  undoes what  Let[ n ]  did.";


(* ::Input::Initialization:: *)
ClearEqn::usage="
ClearEqn[ n ]  will clear the value of  Eqn[ n ].  

ClearEqn[  ]   (no argument)  will clear all  Eqn[ n ]  for all  n.";


(* ::Input::Initialization:: *)
NumberedEqns::usage="
NumberedEqns[]    (no argument)  will return a list of all numbered equations.

NumberedEqns[ n1 , n2 ]    will return a list of the equations with numbers in the range  [ n1 , n2 ]."; 


(* ::Input::Initialization:: *)
LEqn::usage="
LEqn[ n ]  returns the left side of an equation. The argument  n  can be an equation  (i.e.,  Head[ n ]  is  Equal )
 or it can be the label for equation  Eqn[ n ] ,  in which case the value returned is  Eqn[ n ][[ 1 ]] .";


(* ::Input::Initialization:: *)
REqn::usage="
REqn[ n ]  returns the right side of an equation. The argument  n  can be an equation  (i.e.,  Head[ n ]  is  Equal )
 or it can be the label for equation  Eqn[ n ] ,  in which case the value returned is  Eqn[ n ][[ 2 ]] .";


(* ::Input::Initialization:: *)
PrimeTo\[GothicCapitalD]::usage="
To indicate an unevaluated  \[GothicCapitalD]  in an eqn,  the prime  ( )'  can be used. 

PrimeTo\[GothicCapitalD]  is a rule that causes the prime to be replaced and evaluated as  \[GothicCapitalD].";


(* ::Input::Initialization:: *)
\[GothicCapitalD]ToPrime::usage="
\[GothicCapitalD]ToPrime[ s ]   is a rule that can be used to convert an ODE in  \[GothicCapitalD]  to a form suitable for use with DSolve.

 ( This should be replaced by a function  \[GothicCapitalD]Solve[  ]   as a wrapper for  DSolve[  ]. ) ";


(* ::Input::Initialization:: *)
Prime\[GothicCapitalD]::usage="
Prime\[GothicCapitalD][  eqn  ]   returns  eqn   with  ( )'  applied to the left side and  \[GothicCapitalD]  applied to the right side. ";


(* ::Input::Initialization:: *)
SimplifyEqn::usage="
eqn // SimplifyEqn   will apply  Simplify  to each side of  eqn  independently, unlike Simplify which sometimes rearranges equations.";


(* ::Input::Initialization:: *)
FullSimplifyEqn::usage="
eqn // FullSimplifyEqn   will apply  FullSimplify  to each side of  eqn  independently, unlike FullSimplify which sometimes rearranges equations.";


(* ::Input::Initialization:: *)
SolveEqn::usage="
SolveEqn[  eqn,  x  ]   returns  eqn  rearranged so that  x  is on the left side.

The argument  eqn  can be an equation (expression with head Equal), or an equation label or number. ";


(* ::Input::Initialization:: *)
SolveEqns::usage="
SolveEqns[ X__ ]  is the same as  Solve[ X__ ]  except that it temporarily turns off equation checking if need be.

See also:  ? SolveEqn ,  ? EqnCkeckOff ,  ? EqnCkeckOn .";


(* ::Input::Initialization:: *)
EqnCkeckOn::usage="
EqnCkeckOn[\[VeryThinSpace]]  turns on equation checking. 

The left and right sides of a tensor equation are required to have the same type of tensor slots.
If not, computation is aborted and an error message given. 

Equation checking is off by default because it causes errors when the F1 key is used to get a man page. 
The current state is held by the logical variable $EqnCkeckOn (\[VeryThinSpace]True/False if checking is  on/off\[VeryThinSpace]).

See also:  ? SlotType , ? EqnCkeckOff .";


(* ::Input::Initialization:: *)
EqnCkeckOff::usage="
EqnCkeckOff[\[VeryThinSpace]]  turns off equation checking. 

The left and right sides of a tensor equation are required to have the same type of tensor slots.
If not, computation is aborted and an error message given. 

Equation checking is off by default because it causes errors when the F1 key is used to get a man page. 
The current state is held by the logical variable $EqnCkeckOn (\[VeryThinSpace]True/False if checking is on/off\[VeryThinSpace]).

See also:  ? SlotType , ? EqnCkeckOn .";


(* ::Input::Initialization:: *)
Sub::usage="
Sub[ n ]  is the substitution rule obtained from  Eqn[ n ]  by replacing  \"==\"  by  \"\[Rule]\".

E.g., If

   Eqn[ n ] = y == x

then  Sub[ n ]  evaluates to  y \[Rule] x. 

The argument  n  can be an equation number or label, or an equation (expression with head Equal). ";


(* ::Input::Initialization:: *)
RSub::usage="
RSub[ n ][ eqn ]  applies  Sub[n]  to eqn, but does so only on the right side of eqn.

Normally  RSub  is used in the form  \"\[VeryThinSpace]eqn // Rsub[ n ]\[VeryThinSpace]\"\[VeryThinSpace],  and is equivalent to 

                         LEqn[ eqn ] == ( REqn[ eqn ]  /. Sub[ n ] )

The arguments  n  and  eqn  can be an equation numbers, equation labels, or equations (expression with head Equal). ";


(* ::Input::Initialization:: *)
Swap::usage="
Swap[ n ]  returns  Eqn[ n ]  after swapping left and right sides.

The argument  n  can be an equation number or label, or an equation (expression with head Equal). ";


(* ::Input::Initialization:: *)
LEqn[n_]:=If[Head[n]===Equal,n[[1]],Eqn[n][[1]]]
REqn[n_]:=If[Head[n]===Equal,n[[2]],Eqn[n][[2]]]


(* ::Input::Initialization:: *)
Clear[Eqn]


(* ::Input::Initialization:: *)
SetAttributes[Eqn,HoldAll]


(* ::Input::Initialization:: *)
Clear[Let]
SetAttributes[Let,HoldAll]
Let[n_]:=Module[{eq},
eq=Eqn[n];
Eqn[n]=Apply[HoldForm,{Eqn[n]}]/.Equal->Set;
eq/.Equal->Set;
Eqn[n]
]


(* ::Input::Initialization:: *)
Clear[Unlet]
SetAttributes[Unlet,HoldAll]
Unlet[n_]:=Module[{eq,f},
eq=Eqn[n];
eq/.Set->f/.f[x_,y_]:>Unset[x]/.HoldForm->Identity;
Eqn[n]=eq/.Set->Equal/.HoldForm->Identity
]


(* ::Input::Initialization:: *)
Clear[Ref]
Ref[label_/;!NumberQ[label],n_?NumberQ]:=(Ref[label]=n;Ref[n]=label;)


(* ::Input::Initialization:: *)
Clear[Eqns]
SetAttributes[Eqns,HoldAll]
Eqns[x_]:=Select[ Drop[DownValues[Eqn]/.HoldPattern->HoldForm,-3],!FreeQ[#,x]&]
Eqns[]:=Eqns[_]


(* ::Input::Initialization:: *)
Clear[NumberedEqns]
NumberedEqns[]:=Eqns[Eqn[_?NumberQ]]
NumberedEqns[n1_,n2_]:=Eqns[Eqn[x_/;TrueQ[n1<=x<=n2]]]


(* ::Input::Initialization:: *)
Clear[ClearEqn]
SetAttributes[ClearEqn,HoldAll];
ClearEqn[] :=(
Clear[Eqn];
Eqn[x__]/;Length[{x}]>1:=Eqn[{x}];
Eqn[X_List]:=Flatten[Map[Eqn,X]];Eqn[n_?NumberQ]:=Eqn[Evaluate[Ref[n]]])


(* ::Input::Initialization:: *)
ClearEqn[x_]:=Quiet[Eqn[x]=.;]


(* ::Input::Initialization:: *)
ClearEqn[]


(* ::Input::Initialization:: *)
PrimeTo\[GothicCapitalD][]:=Derivative[n_Integer][f_]:>\[GothicCapitalD][f,n]
PrimeTo\[GothicCapitalD][s_]:=Derivative[n_Integer][f_][s]:>\[GothicCapitalD][f[s],n]


(* ::Input::Initialization:: *)
\[GothicCapitalD]ToPrime[ ]:={\[GothicCapitalD][f_]:>Derivative[1][f],\[GothicCapitalD][f_,n_]:>Derivative[n][f]}
\[GothicCapitalD]ToPrime[s_ ]:={\[GothicCapitalD][f_[s]]:>Derivative[1][f][s],\[GothicCapitalD][f_[s],n_]:>Derivative[n][f][s]}


(* ::Input::Initialization:: *)
Prime\[GothicCapitalD][a_==b_]:=(a)'= \[GothicCapitalD][b]
Prime\[GothicCapitalD][a_->b_]:=(a)'-> \[GothicCapitalD][b]
Prime\[GothicCapitalD][a_:>b_]:=(a)':> \[GothicCapitalD][b]


(* ::Input::Initialization:: *)
Prime\[GothicCapitalD][a_==b_,n_Integer]:=Derivative[n][a]= \[GothicCapitalD][b,n]
Prime\[GothicCapitalD][a_->b_,n_Integer]:=Derivative[n][a]-> \[GothicCapitalD][b,n]
Prime\[GothicCapitalD][a_:>b_,n_Integer]:=Derivative[n][a]:> \[GothicCapitalD][b,n]


(* ::Input::Initialization:: *)
\[GothicCapitalD][a_==b_]:=\[GothicCapitalD][a]== \[GothicCapitalD][b]
\[GothicCapitalD][a_->b_]:=\[GothicCapitalD][a]-> \[GothicCapitalD][b]
\[GothicCapitalD][a_:>b_]:=\[GothicCapitalD][a]:> \[GothicCapitalD][b]


(* ::Input::Initialization:: *)
\[GothicCapitalD][a_==b_,n_Integer]:=\[GothicCapitalD][a,n]== \[GothicCapitalD][b,n]
\[GothicCapitalD][a_->b_,n_Integer]:=\[GothicCapitalD][a,n]-> \[GothicCapitalD][b,n]
\[GothicCapitalD][a_:>b_,n_Integer]:=\[GothicCapitalD][a,n]:> \[GothicCapitalD][b,n]


(* ::Input::Initialization:: *)
SimplifyEqn[Equal[a1_,a2_],assum___]:=Simplify[a1,assum]==Simplify[a2,assum]


(* ::Input::Initialization:: *)
FullSimplifyEqn[Equal[a1_,a2_],assum___]:=FullSimplify[a1,assum]==FullSimplify[a2,assum]


(* ::Input::Initialization:: *)
SimplifyEqn[True,assum___]=True;
FullSimplifyEqn[True,assum___]=True;


(* ::Input::Initialization:: *)
SimplifyEqn[False,assum___]=False;
FullSimplifyEqn[False,assum___]=False;


(* ::Input::Initialization:: *)
SimplifyTensor[Equal[a1_,a2_]]:=Equal[SimplifyTensor[a1],SimplifyTensor[a2]]


(* ::Input::Initialization:: *)
FullSimplifyTensor[Equal[a1_,a2_]]:=Equal[FullSimplifyTensor[a1],FullSimplifyTensor[a2]]


(* ::Input::Initialization:: *)
ExpandTensor[Equal[a1_,a2_]]:=Equal[ExpandTensor[a1],ExpandTensor[a2]]


(* ::Input::Initialization:: *)
ExpandAllTensor[Equal[a1_,a2_]]:=Equal[ExpandAllTensor[a1],ExpandAllTensor[a2]]


(* ::Input::Initialization:: *)
degCheck[Equal[a1_,a2_]]:= degCheck[{a1,a2}]


(* ::Input::Initialization:: *)
SimplifyTensor[True]=True;
FullSimplifyTensor[True]=True;
ExpandTensor[True]=True;
ExpandAllTensor[True]=True;


(* ::Input::Initialization:: *)
SimplifyTensor[False]=False;
FullSimplifyTensor[False]=False;
ExpandTensor[False]=False;
ExpandAllTensor[False]=False;


(* ::Input::Initialization:: *)
NotEqn[x_]:=!Head[x]=== Equal


(* ::Input::Initialization:: *)
EqnCheckOn[] :=(
$EqnCheckOn=True;
Unprotect[Equal];
Equal/: Equal[a_,b_]/;!SlotType[a]===SlotType[b]&&!SlotType[a]===SlotType[$ZeroTensor]&&!SlotType[b]===SlotType[$ZeroTensor]:=(
Print["Left and right sides of an equation must have the same tensor slot type,"];
Print[];
Print[SlotType[a]," \[NotEqual] ",SlotType[b],"."];
Print[];
Print["NB. If errors are reported while using Solve[\[VeryThinSpace]], then equation checking should be"];
Print["turned off using  EqnCheckOff[\[VeryThinSpace]]. Checking can be turned back on using  EqnCheckOn[\[VeryThinSpace]]."];
Print["See also: ?SolveEqns[\[VeryThinSpace]] "];
Abort[]);
Protect[Equal];)


(* ::Input::Initialization:: *)
EqnCheckOff[] :=(
$EqnCheckOn=False;
Unprotect[Equal];
Quiet[Equal/: Equal[a_,b_]/;!SlotType[a]===SlotType[b]&&!SlotType[a]===SlotType[$ZeroTensor]&&!SlotType[b]===SlotType[$ZeroTensor]=.];
Protect[Equal];)


(* ::Input::Initialization:: *)
EqnCheckOff[]


(* ::Input::Initialization:: *)
SlotType[X_Equal]:=If[SlotType[X[[1]]]===SlotType[X[[2]]]||X[[1]]===0||X[[2]]===0,
If[X[[1]]=== 0,SlotType[X[[2]]],SlotType[X[[1]]]],
Print[SlotType[X[[1]]]," \[NotEqual] ",SlotType[X[[2]]],"."];
Abort[]]


(* ::Input::Initialization:: *)
Unprotect[Equal];


(* ::Input::Initialization:: *)
Equal/: Equal[a1_,b1_]+Equal[a2_,b2_]:= Equal[a1+a2,b1+b2]


(* ::Input::Initialization:: *)
Equal/: Equal[a1_,b1_]Equal[a2_,b2_]:= Equal[a1 a2,b1 b2]


(* ::Input::Initialization:: *)
Equal/: \[LeftAngleBracket]y1___,Equal[a1_,b1_],y2___,Equal[a2_,b2_],y3___\[RightAngleBracket]:= Equal[\[LeftAngleBracket]y1,a1,y2,a2,y3\[RightAngleBracket],\[LeftAngleBracket]y1,b1,y2, b2,y3\[RightAngleBracket]]


(* ::Input::Initialization:: *)
Equal/: y1___\[CircleTimes]Equal[a1_,b1_]\[CircleTimes]y2___\[CircleTimes]Equal[a2_,b2_]\[CircleTimes]y3___:= Equal[y1\[CircleTimes]a1\[CircleTimes]y2\[CircleTimes]a2\[CircleTimes]y3,y1\[CircleTimes]b1\[CircleTimes]y2\[CircleTimes]b2\[CircleTimes]y3]


(* ::Input::Initialization:: *)
Equal/:Star[x___,Equal[a1_,b1_],y___,Equal[a2_,b2_],z___]:=Star[x,a1,y,a2,z]==Star[x,b1,y,b2,z]


(* ::Input::Initialization:: *)
Protect[Equal];


(* ::Input::Initialization:: *)
Unprotect[Equal];


(* ::Input::Initialization:: *)
Equal/:\[LeftAngleBracket]Equal[a_,b_],c__?NotEqn\[RightAngleBracket]:=Equal[\[LeftAngleBracket]a,c\[RightAngleBracket],\[LeftAngleBracket]b,c\[RightAngleBracket]]


(* ::Input::Initialization:: *)
Equal/:\[LeftAngleBracket]c__?NotEqn,Equal[a_,b_]\[RightAngleBracket]:=Equal[\[LeftAngleBracket]c,a\[RightAngleBracket],\[LeftAngleBracket]c,b\[RightAngleBracket]]


(* ::Input::Initialization:: *)
Equal/:\[LeftAngleBracket]c__?NotEqn,Equal[a_,b_],d__?NotEqn\[RightAngleBracket]:=Equal[\[LeftAngleBracket]c,a,d\[RightAngleBracket],\[LeftAngleBracket]c,b,d\[RightAngleBracket]]


(* ::Input::Initialization:: *)
Equal/:\[CurlyEpsilon]4Dual[Equal[a_,b_]]:=Equal[\[CurlyEpsilon]4Dual[a],\[CurlyEpsilon]4Dual[b]]


(* ::Input::Initialization:: *)
Subscript[\[LeftAngleBracket]Equal[a_,b_]\[RightAngleBracket], ab__List]:=Equal[Subscript[\[LeftAngleBracket]a\[RightAngleBracket], ab],Subscript[\[LeftAngleBracket]b\[RightAngleBracket], ab]]


(* ::Input::Initialization:: *)
Equal/:Equal[a_,b_]\[CircleTimes]c__?NotEqn:=a\[CircleTimes]c==b\[CircleTimes]c


(* ::Input::Initialization:: *)
Equal/:c__?NotEqn\[CircleTimes]Equal[a_,b_]:=c\[CircleTimes]a==c\[CircleTimes]b


(* ::Input::Initialization:: *)
Equal/:c__?NotEqn\[CircleTimes]Equal[a_,b_]\[CircleTimes]d__?NotEqn:=c\[CircleTimes]a\[CircleTimes]d==c\[CircleTimes]b\[CircleTimes]d


(* ::Input::Initialization:: *)
Equal/:Equal[a_,b_] + c_?NotEqn:=Equal[a+c,b+c]


(* ::Input::Initialization:: *)
Equal/:Equal[a_,b_]  c_?NotEqn:=Equal[a c,b c]


(* ::Input::Initialization:: *)
Equal/:Equal[a_,b_] ^n_:=Equal[a^n,b^n]


(* ::Input::Initialization:: *)
Equal/:Coefficient[Equal[a_,b_],c__]:=Coefficient[a,c]== Coefficient[b,c]


(* ::Input::Initialization:: *)
Equal/:rev[Equal[a_,b_]]:=rev[a]==rev[b]


(* ::Input::Initialization:: *)
Equal/:mv[n___][Equal[a_,b_]]:=mv[n][a]==mv[n][b]


(* ::Input::Initialization:: *)
Equal/:Star[x___,Equal[a_,b_],y___]:=Star[x,a,y]==Star[x,b,y]


(* ::Input::Initialization:: *)
Protect[Equal];


(* ::Input::Initialization:: *)
Unprotect[Equal];


(* ::Input::Initialization:: *)
Equal/:Exp[Equal[a_,b_]]:=Exp[a]==Exp[b]


(* ::Input::Initialization:: *)
Equal/:Log[Equal[a_,b_]]:=Log[a]==Log[b]


(* ::Input::Initialization:: *)
Equal/:Abs[Equal[a_,b_]]:=Abs[a]==Abs[b]


(* ::Input::Initialization:: *)
Protect[Equal];


(* ::Input::Initialization:: *)
Unprotect[Equal];


(* ::Input::Initialization:: *)
Equal/:\[Del] Equal[a_,b_]:=Equal[\[Del]a,\[Del]b]


(* ::Input::Initialization:: *)
Equal/:\[GothicCapitalD][Equal[a_,b_]]:=Equal[\[GothicCapitalD][a],\[GothicCapitalD][b]]


(* ::Input::Initialization:: *)
Equal/:\[GothicCapitalD][Equal[a_,b_],n_]:=Equal[\[GothicCapitalD][a,n],\[GothicCapitalD][b,n]]


(* ::Input::Initialization:: *)
Equal/:Ds[Equal[a_,b_]]:=Equal[Ds[a],Ds[b]]


(* ::Input::Initialization:: *)
Equal/:Ds[Equal[a_,b_],n_]:=Equal[Ds[a,n],Ds[b,n]]


(* ::Input::Initialization:: *)
Equal/:pD[Equal[a_,b_],x__]:=Equal[pD[a,x],pD[b,x]]


(* ::Input::Initialization:: *)
Protect[Equal];


(* ::Input::Initialization:: *)
Clear[CrossEqn]
SetAttributes[CrossEqn,HoldAll]


(* ::Input::Initialization:: *)
CrossEqn[eqn_Equal]:=Numerator[LEqn[eqn]]Denominator[REqn[eqn]]==Numerator[REqn[eqn]]Denominator[LEqn[eqn]]


(* ::Input::Initialization:: *)
CrossEqn[n_/;NotEqn[n]&&ValueQ[Eqn[n]]]:=CrossEqn[Evaluate[Eqn[n]]]


(* ::Input::Initialization:: *)
CrossEqn[n_/;Head[n]===Equal]:=CrossEqn[Evaluate[n]]


(* ::Input::Initialization:: *)
Clear[SolveEqn]
SetAttributes[SolveEqn,HoldFirst]


(* ::Input::Initialization:: *)
SolveEqn[eq_Equal,a_]:=Module[{soln,check},
check =$EqnCheckOn;
If[check,EqnCheckOff[]];
soln=Solve[eq,a];
If[check,EqnCheckOn[]];
If[Length[soln]>1,
Print["More than one solution."];Return[]];
If[Length[soln]===0,
Print["No solution."]Return[]];
First[First[soln]]/.Rule->Equal]


(* ::Input::Initialization:: *)
SolveEqn[n_/;NotEqn[n]&&ValueQ[Eqn[n]],a_]:=SolveEqn[Evaluate[Eqn[n]],a]


(* ::Input::Initialization:: *)
SolveEqn[n_/;Head[n]===Equal,a_]:=SolveEqn[Evaluate[n],a]


(* ::Input::Initialization:: *)
SolveEqns[X__]:=Module[{soln,check},
check =$EqnCheckOn;
If[check,EqnCheckOff[]];
soln=Solve[X];
If[check,EqnCheckOn[]];
soln
]


(* ::Input::Initialization:: *)
Rules[x_List,y_List]/;Dimensions[x]===Dimensions[y]:= MapThread[Rule,{Flatten[x],Flatten[y]}]


(* ::Input::Initialization:: *)
Rules[x_,y_]:=Rule[x,y]


(* ::Input::Initialization:: *)
Clear[Sub]
SetAttributes[Sub,HoldAll]


(* ::Input::Initialization:: *)
Sub[eq_/;Head[eq]===Equal&&!ValueQ[Eqn[eq]]]:=Flatten[{eq/.Equal->Rules}]


(* ::Input::Initialization:: *)
Sub[eq_/;Head[eq]===Equal&&ValueQ[Eqn[eq]]]:= (Print["Sub[",HoldForm[eq],"] is ambiguous: 
Argument ",HoldForm[eq]," is being used as both a label for ", Defer[Eqn[eq ]]," and as a symbol to which an equation has been assigned." ];{})


(* ::Input::Initialization:: *)
Sub[eq_/;Head[eq]===HoldForm]:={eq}/.Set->Rule/.HoldForm->Identity


(* ::Input::Initialization:: *)
Eqn[x34]=xxxx==643


(* ::Input::Initialization:: *)
Let[]


(* ::Input::Initialization:: *)
Sub[n_/;NotEqn[n]&&!Head[n]===HoldForm&&ValueQ[Eqn[n]]&&!Head[n]===List]:=Sub[Evaluate[Eqn[n]]]


(* ::Input::Initialization:: *)
Sub[Y__/;Length[{Y}]>1]:=Flatten[Map[Sub,{Y}]]


(* ::Input::Initialization:: *)
Sub[{eq_,x_}]:=Module[{eq1},
eq1=SolveEqn[eq,x];
{eq1}/.Equal->Rule]


(* ::Input::Initialization:: *)
RSub[ n__ ][ eqn_Equal ] := LEqn[eqn] == (REqn[eqn]//.Sub[n])


(* ::Input::Initialization:: *)
RSub[n__][x_]:= x==(x//.Sub[n])


(* ::Input::Initialization:: *)
RSub1[ n__ ][ eqn_Equal ] := LEqn[eqn] == (REqn[eqn]/.Sub[n])
RSub1[n__][x_]:= x==(x/.Sub[n])


(* ::Input::Initialization:: *)
Clear[Swap]
SetAttributes[Swap,HoldAll]


(* ::Input::Initialization:: *)
Swap[Equal[a_,b_]]:=Equal[b,a]


(* ::Input::Initialization:: *)
Swap[n_/;NotEqn[n]&&ValueQ[Eqn[n]]]:=Swap[Evaluate[Eqn[n]]]


(* ::Input::Initialization:: *)
Swap[n_/;Head[n]===Equal]:=Swap[Evaluate[n]]


(* ::Input::Initialization:: *)
noTeX[x_]:=x


(* ::Input::Initialization:: *)
nonumber[ x_]:=x   


(* ::Input::Initialization:: *)
$HiddenColor = RGBColor[{55,180,55}/255.];
Format[Hidden[x_],StandardForm]:=Style[x,FontColor ->$HiddenColor];
noleft[x_]:=x


(* ::Code::Initialization:: *)
If[$Pre===PreTeXit||$Pre===PreTeXit1,$Pre=.]
Clear[PreTeXit]
SetAttributes[PreTeXit, HoldAll];

PreTeXit[x_]:= 
(
   If[ MatchQ[ Hold[x], Hold[ Eqn[_] = _]] && !MatchQ[ Hold[x], Hold[Eqn[_] = noTeX[_]]],
      If[ MatchQ[ Hold[x], Hold[ Eqn[_] = nonumber[_]]],
         TeXit[x]
         ,
         TeXit[x, ToString[First[Extract[Hold[x], {1,1,1}, Hold]]]]
      ]
   ];
   x
)

PreTeXit[x_]:= 
   If[ MatchQ[ Hold[x], Hold[Eqn[_] = _]] && !MatchQ[ Hold[x], Hold[Eqn[_] = noTeX[_]]],
      If[ MatchQ[ Hold[x], Hold[Eqn[_] = noleft[nonumber[_]]] ] || MatchQ[ Hold[x], Hold[Eqn[_] = nonumber[noleft[_]]] ],
         TeXit[HiddenLeftEqn == REqn[x]];
         Hidden[LEqn[x]]== REqn[x] // TeXitBackground
         ,
         If[ MatchQ[ Hold[x], Hold[Eqn[_] = nonumber[_]] ],
            TeXit[x]
            ,
            If[ MatchQ[ Hold[x], Hold[Eqn[_] = noleft[_]] ],
               TeXit[HiddenLeftEqn == REqn[x], ToString[First[Extract[Hold[x], {1,1,1}, Hold]]]];
               Hidden[LEqn[x]]== REqn[x] // TeXitBackground
               ,
               TeXit[x, ToString[First[Extract[Hold[x], {1,1,1}, Hold]]]]
            ]
         ]      
      ]
      ,
      If[ MatchQ[ Hold[x], Hold[Eqn[_] = noTeX[_]]],
         x // noTeXitBackground
         ,
         If[ MatchQ[ Hold[x], Hold[noTeX[_]]],
            x // noTeXitBackground
            ,
            If[ MatchQ[ Hold[x], Hold[noleft[_]]],
               TeXit[HiddenLeftEqn == REqn[x]];
               Hidden[LEqn[x]]== REqn[x] // TeXitBackground
               ,
               x
            ]   
         ]   
      ]   
   ]


(* ::Input::Initialization:: *)
StartAutoTeXit[]:=
If[!ValueQ[$Pre],
    $Pre=PreTeXit
    ,
    If[!($Pre===PreTeXit||$Pre===PreTeXit1),
       OriginalPre = $Pre;
       PreTeXit1[x_]:= PreTeXit[OriginalPre[x]];
       $Pre = PreTeXit1
  ]
];


(* ::Input::Initialization:: *)
StopAutoTeXit[]:=
  If[ValueQ[OriginalPre],
    $Pre=OriginalPre
    ,
    $Pre =.
  ]


(* ::Input::Initialization:: *)
If[TrueQ[$PrintDebugLocation],Print["End of Part5"]]
SaveInitTime[]
